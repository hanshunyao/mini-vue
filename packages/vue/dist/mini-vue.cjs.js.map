{"version":3,"file":"mini-vue.cjs.js","sources":["../../shared/src/toDisplayString.ts","../../shared/src/index.ts","../../runtime-core/src/vnode.ts","../../runtime-core/src/h.ts","../../runtime-core/src/createApp.ts","../../runtime-core/src/componentProps.ts","../../runtime-core/src/componentSlots.ts","../../runtime-core/src/componentEmits.ts","../../runtime-core/src/componentPublicInstance.ts","../../reactivity/src/dep.ts","../../reactivity/src/effect.ts","../../reactivity/src/baseHandlers.ts","../../reactivity/src/reactive.ts","../../reactivity/src/ref.ts","../../reactivity/src/computed.ts","../../runtime-core/src/component.ts","../../runtime-core/src/apiInject.ts","../../runtime-core/src/helpers/renderSlot.ts","../../runtime-core/src/scheduler.ts","../../runtime-core/src/componentRenderUtils.ts","../../runtime-core/src/renderer.ts","../../runtime-dom/src/index.ts","../../compiler-core/src/runtimeHelpers.ts","../../compiler-core/src/codegen.ts","../../compiler-core/src/parse.ts","../../compiler-core/src/transform.ts","../../compiler-core/src/transforms/transformExpression.ts","../../compiler-core/src/ast.ts","../../compiler-core/src/transforms/transformElement.ts","../../compiler-core/src/utils.ts","../../compiler-core/src/transforms/transformText.ts","../../compiler-core/src/compile.ts","../src/index.ts"],"sourcesContent":["export const toDisplayString = (val) => {\n  return String(val);\n};\n","export * from \"./shapeFlags\";\nexport * from \"./toDisplayString\";\n\nexport const isObject = (val) => {\n  return val !== null && typeof val === \"object\";\n};\n\nexport const isString = (val) => typeof val === \"string\";\n\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n * 把烤肉串命名方式转换成驼峰命名方式\n */\nexport const camelize = (str: string): string => {\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : \"\"));\n};\n\nexport const extend = Object.assign;\n\n// 必须是 on+一个大写字母的格式开头\nexport const isOn = (key) => /^on[A-Z]/.test(key);\n\nexport function hasChanged(value, oldValue) {\n  return !Object.is(value, oldValue);\n}\n\nexport function hasOwn(val, key) {\n  return Object.prototype.hasOwnProperty.call(val, key);\n}\n\n/**\n * @private\n * 首字母大写\n */\nexport const capitalize = (str: string) =>\n  str.charAt(0).toUpperCase() + str.slice(1);\n\n/**\n * @private\n * 添加 on 前缀，并且首字母大写\n */\nexport const toHandlerKey = (str: string) =>\n  str ? `on${capitalize(str)}` : ``;\n\n// 用来匹配 kebab-case 的情况\n// 比如 onTest-event 可以匹配到 T\n// 然后取到 T 在前面加一个 - 就可以\n// \\BT 就可以匹配到 T 前面是字母的位置\nconst hyphenateRE = /\\B([A-Z])/g;\n/**\n * @private\n */\nexport const hyphenate = (str: string) =>\n  str.replace(hyphenateRE, \"-$1\").toLowerCase();\n","import { ShapeFlags } from '@mini-vue/shared';\nexport { createVNode as createElementVNode };\n\n// 这里后面两个参数可选\nexport const createVNode = function (\n  type: any,\n  props?: any,\n  children?: string | Array<any>\n) {\n  // 注意 type 有可能是 string 也有可能是对象\n  // 如果是对象的话，那么就是用户设置的 options\n  // type 为 string 的时候\n  // createVNode(\"div\")\n  // type 为组件对象的时候\n  // createVNode(App)\n  const vnode = {\n    // 初始化时 el 设置为 null，后面这个字段用于存储根节点 通过 $el 访问\n    el: null,\n    component: null,\n    key: props?.key,\n    type,\n    props: props || {},\n    children,\n    shapeFlag: getShapeFlag(type),\n  };\n\n  // 基于 children 再次设置 shapeFlag\n  if (Array.isArray(children)) {\n    // 这里用了 或 的操作 ，或 是 都是 0 ，结果才是 0，只要有一个是 1 ，结果就是 1\n    // 这两个 type 在自己 对应的位上都是 1 所以只要 和 之前的类型 或 上，结果就肯定在原有基础上 把新的位置为1\n    vnode.shapeFlag |= ShapeFlags.ARRAY_CHILDREN;\n  } else if (typeof children === 'string') {\n    vnode.shapeFlag |= ShapeFlags.TEXT_CHILDREN;\n  }\n\n  // 这里判断一下 children 是不是 slot 如果是 slot 位运算一下，后面处理\n  normalizeChildren(vnode, children);\n  return vnode;\n};\n\nexport function normalizeChildren(vnode, children) {\n  if (typeof children === 'object') {\n    // 暂时主要是为了标识出 slots_children 这个类型来\n    // 暂时我们只有 element 类型和 component 类型的组件\n    // 所以我们这里除了 element ，那么只要是 component 的话，那么children 肯定就是 slots 了\n    if (vnode.shapeFlag & ShapeFlags.ELEMENT) {\n      // 如果是 element 类型的话，那么 children 肯定不是 slots\n    } else {\n      // 这里就必然是 component 了,\n      vnode.shapeFlag |= ShapeFlags.SLOTS_CHILDREN;\n    }\n  }\n}\n\n// 用 symbol 作为唯一标识\nexport const Text = Symbol('Text');\nexport const Fragment = Symbol('Fragment');\n\nexport function createTextVNode(text: string = ' ') {\n  return createVNode(Text, {}, text);\n}\n\n// 标准化 vnode 的格式\n// 其目的是为了让 child 支持多种格式\nexport function normalizeVNode(child) {\n  // 暂时只支持处理 child 为 string 和 number 的情况\n  if (typeof child === 'string' || typeof child === 'number') {\n    return createVNode(Text, null, String(child));\n  } else {\n    return child;\n  }\n}\n\n// 基于 type 来判断是什么类型的组件\nfunction getShapeFlag(type: any) {\n  return typeof type === 'string'\n    ? ShapeFlags.ELEMENT\n    : ShapeFlags.STATEFUL_COMPONENT;\n}\n","import { createVNode } from './vnode';\n// h 就是调用 createVNode 对于外部用户更方便使用\nexport const h = (\n  type: any,\n  props: any = null,\n  children: string | Array<any> = []\n) => {\n  return createVNode(type, props, children);\n};\n","import { createVNode } from './vnode';\n\nexport function createAppAPI(render) {\n  // 这里 调用 createdApp 传入 根组件\n  // 然后返回一个 app 对象\n  return function createApp(rootComponent) {\n    // 返回的对象中 有着 mount 方法用于挂载根节点\n    // 这里的 rootContainer 就是根节点\n    const app = {\n      _component: rootComponent,\n      mount(rootContainer) {\n        console.log('基于根组件创建 vnode');\n\n        // 把根组件转换成 vnode\n        // 后续所有的操作都会基于 vnode 做处理\n        const vnode = createVNode(rootComponent);\n        console.log('调用 render，基于 vnode 进行开箱');\n        render(vnode, rootContainer);\n      },\n    };\n    return app;\n  };\n}\n","export function initProps(instance, rawProps) {\n  console.log('initProps');\n\n  // TODO\n  // 应该还有 attrs 的概念\n  // attrs\n  // 如果组件声明了 props 的话，那么才可以进入 props 属性内\n  // 不然的话是需要存储在 attrs 内\n  // 这里暂时直接赋值给 instance.props 即可\n  instance.props = rawProps || {};\n}\n","import { ShapeFlags } from '@mini-vue/shared';\r\nexport function initSlots(instance, children) {\r\n  // 把 children 存到 instance 上\r\n  const { vnode } = instance;\r\n  console.log('初始化 slots');\r\n  // 前面 vnode 在 createVNode 中已经处理过了经过了位运算，这里可以筛选一下 如果是 slots 就特殊处理\r\n  if (vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN) {\r\n    normalizeObjectSlots(children, (instance.slots = {}));\r\n  }\r\n}\r\n\r\nconst normalizeSlotValue = (value) => {\r\n  // 把 function 返回的值转换成 array ，这样 slot 就可以支持多个元素了\r\n  return Array.isArray(value) ? value : [value];\r\n};\r\n\r\nconst normalizeObjectSlots = (rawSlots, slots) => {\r\n  for (const key in rawSlots) {\r\n    // 这个是 父组件上的 插槽方法，找到对应的父组件插槽，把 props 传进去\r\n    const value = rawSlots[key];\r\n    if (typeof value === 'function') {\r\n      // 把这个函数给到slots 对象上存起来\r\n      // 后续在 renderSlot 中调用\r\n      // TODO 这里没有对 value 做 normalize，\r\n      // 默认 slots 返回的就是一个 vnode 对象\r\n      slots[key] = (props) => normalizeSlotValue(value(props));\r\n    }\r\n  }\r\n};\r\n","import { camelize, hyphenate, toHandlerKey } from '@mini-vue/shared';\nexport function emit(instance, event: string, ...rawArgs) {\n  console.log('emit', event);\n  // 1. emit 是基于 props 里面的 onXXX 的函数来进行匹配的\n  // 所以我们先从 props 中看看是否有对应的 event handler\n  const props = instance.props;\n  // ex: event -> click 那么这里取的就是 onClick\n  // 让事情变的复杂一点如果是烤肉串命名的话，需要转换成  change-page -> changePage\n  // 需要得到事件名称\n  let handler = props[toHandlerKey(camelize(event))];\n\n  // 如果上面没有匹配的话 那么在检测一下 event 是不是 kebab-case 类型\n  if (!handler) {\n    handler = props[toHandlerKey(hyphenate(event))];\n  }\n\n  if (handler) {\n    handler(...rawArgs);\n  }\n}\n","import { hasOwn } from '@mini-vue/shared';\n\nconst publicPropertiesMap = {\n  // 当用户调用 instance.proxy.$emit 时就会触发这个函数\n  // i 就是 instance 的缩写 也就是组件实例对象\n  $el: (i) => i.vnode.el,\n  $emit: (i) => i.emit,\n  $slots: (i) => i.slots,\n  $props: (i) => i.props,\n};\n\n// todo 需要让用户可以直接在 render 函数内直接使用 this 来触发 proxy\nexport const PublicInstanceProxyHandlers = {\n  get({ _: instance }, key) {\n    // 用户访问 proxy[key]\n    // 这里就匹配一下看看是否有对应的 function\n    // 有的话就直接调用这个 function\n    const { setupState, props } = instance;\n    console.log(`触发 proxy hook , key -> : ${key}`);\n\n    if (key[0] !== '$') {\n      // 说明不是访问 public api\n      // 先检测访问的 key 是否存在于 setupState 中, 是的话直接返回\n      if (hasOwn(setupState, key)) {\n        return setupState[key];\n      } else if (hasOwn(props, key)) {\n        // 看看 key 是不是在 props 中\n        // 代理是可以访问到 props 中的 key 的\n        return props[key];\n      }\n    }\n\n    const publicGetter = publicPropertiesMap[key];\n\n    if (publicGetter) {\n      return publicGetter(instance);\n    }\n  },\n\n  set({ _: instance }, key, value) {\n    const { setupState } = instance;\n\n    if (hasOwn(setupState, key)) {\n      // 有的话 那么就直接赋值\n      setupState[key] = value;\n    }\n\n    return true;\n  },\n};\n","// 用于存储所有的 effect 对象\nexport function createDep(effects?) {\n  const dep = new Set(effects);\n  return dep;\n}\n","/*\r\n * @Author: hansy hanshunyao_hansy@163.com\r\n * @Date: 2025-03-07 14:56:39\r\n * @LastEditors: Hansy hanshunyao_hansy@163.com\r\n * @LastEditTime: 2025-03-09 18:51:15\r\n * @FilePath: \\mini-vue\\src\\reactivity\\effect.ts\r\n * @Description: effect 主逻辑\r\n */\r\nimport { createDep } from './dep';\r\nimport { extend } from '@mini-vue/shared';\r\n\r\nlet activeEffect = void 0;\r\n\r\n// 用于判断是否要执行依赖收集\r\n// 只有在 effect 函数执行的时候，才会执行依赖收集\r\n// 其他情况都不会执行依赖收集\r\nlet shouldTrack = false;\r\nconst targetMap = new WeakMap();\r\n\r\n// 用于依赖收集\r\nexport class ReactiveEffect {\r\n  // 默认状态 true , 当调用 stop 后变为 false 后续再次调用stop 跳过遍历逻辑 节省效率\r\n  active = true;\r\n  //　反向收集 依赖 , deps 里面装的是 所有该实例依赖的所有响应式对象\r\n  deps = [];\r\n  // effect 第二个参数 options.onStop\r\n  // 用于在 stop 后的回调函数\r\n  public onStop?: () => void;\r\n  // fn 是用户传入的函数\r\n  // scheduler 可选\r\n  // trigger 执行时 如果有 scheduler 就执行 effect 的 scheduler\r\n  // 如果没有 就执行 effect.run\r\n  constructor(public fn, public scheduler?) {\r\n    console.log('创建 ReactiveEffect 对象');\r\n  }\r\n\r\n  run() {\r\n    console.log('run');\r\n    // 判断 这个函数 有没有被 stop\r\n    if (!this.active) {\r\n      // 如果被 stop 了，执行函数 返回函数 但是不收集依赖\r\n      return this.fn();\r\n    }\r\n\r\n    // 如果 effect 是 active 状态的时候 标记开始收集依赖\r\n    shouldTrack = true;\r\n\r\n    // 执行的时候给全局的 activeEffect 赋值\r\n    // 利用全局属性来获取当前的 effect\r\n    activeEffect = this as any;\r\n    // 执行用户传入的 fn\r\n    console.log('执行用户传入的 fn');\r\n    // 这个地方执行 用户传来的函数 会触发 get =》 track 操作进行收集依赖\r\n    const result = this.fn();\r\n\r\n    // 收集依赖后 关闭依赖收集的标签\r\n    shouldTrack = false;\r\n    // 清空 activeEffect 全局变量\r\n    activeEffect = undefined;\r\n\r\n    return result;\r\n  }\r\n\r\n  stop() {\r\n    if (this.active) {\r\n      // 如果第一次执行 stop 后 active 就 false 了\r\n      // 这是为了防止重复的调用，执行 stop 逻辑\r\n      cleanupEffect(this);\r\n      // 如果传入了 option.onStop 就在 stop 后执行函数\r\n      if (this.onStop) {\r\n        this.onStop();\r\n      }\r\n      this.active = false;\r\n    }\r\n  }\r\n}\r\n\r\nfunction cleanupEffect(effect) {\r\n  // 找到所有依赖这个 effect 的响应式对象\r\n  // 从这些响应式对象里面把 effect 给删除掉\r\n  effect.deps.forEach((dep) => {\r\n    dep.delete(effect);\r\n  });\r\n\r\n  effect.deps.length = 0;\r\n}\r\n\r\nexport function effect(fn, options = {}) {\r\n  // 这个地方使用了面向对象的思想，将函数抽象成一个类\r\n  // 给每个类 都带有一个 run 方法\r\n  // 在执行 run 方法的时候进行依赖收集\r\n  const _effect = new ReactiveEffect(fn);\r\n\r\n  // 把用户传过来的值合并到 _effect 对象上去\r\n  // 优点是 后续不管 options 有多少个属性，都可以合并到 _effect 对象上\r\n  // 缺点就是不是显式的，看代码的时候并不知道有什么属性\r\n  // 这个地方 参考 @vue/shared 把公共方法提取到了 shared 中，其实封装的就是 Object.assign\r\n  extend(_effect, options);\r\n  _effect.run();\r\n\r\n  // 把 _effect.run 这个方法返回\r\n  // 让用户可以自行选择调用的时机（调用 fn）\r\n  const runner: any = _effect.run.bind(_effect);\r\n  // 把 _effect 对象挂载到 runner 上\r\n  // 这样 调用 stop 的时候就可以通过 runner 上面的 effect.stop 方法实现\r\n  runner.effect = _effect;\r\n  return runner;\r\n}\r\n\r\nexport function stop(runner) {\r\n  runner.effect.stop();\r\n}\r\n\r\nexport function track(target, type, key) {\r\n  if (!isTracking()) {\r\n    return;\r\n  }\r\n  console.log(`触发 track -> target: ${target} type:${type} key:${key}`);\r\n  // 先基于 对象 找到对应的 map\r\n  // 这个 map 是所有的依赖数据\r\n  // 如果是第一次的话，那么就需要初始化\r\n  let depsMap = targetMap.get(target);\r\n  if (!depsMap) {\r\n    // 初始化 depsMap 的逻辑\r\n    depsMap = new Map();\r\n    targetMap.set(target, depsMap);\r\n  }\r\n  // 通过 对象 改变的 key 来查询 所有的依赖 effect\r\n  // 这里 查出来的 dep 是一个 set 来确保 依赖不会被重复收集\r\n  let dep = depsMap.get(key);\r\n\r\n  if (!dep) {\r\n    dep = createDep();\r\n    depsMap.set(key, dep);\r\n  }\r\n\r\n  // 这里把逻辑抽离出来 到 trackEffects 中\r\n  // reactive 需要寻找 它对应 key 的 依赖集合列表\r\n  // 而 ref 不需要这一步，所以 如果是 ref 调用的时候 就直接 调用 trackEffects 就可以了\r\n  // 而 reactive 就调用 track 找到对应的 set 再进行 trackEffects\r\n  trackEffects(dep);\r\n}\r\n\r\nexport function trackEffects(dep) {\r\n  // 传进来的 dep 是 该 key 之前所对应的 effect 列表\r\n  // 要把新收集到的 effct 加入到 dep 中\r\n\r\n  // 这里是一个优化点\r\n  // 先看看这个依赖是不是已经收集了，\r\n  // 已经收集的话，那么就不需要在收集一次了\r\n  // 可能会影响 code path change 的情况\r\n  // 需要每次都 cleanupEffect\r\n  // shouldTrack = !dep.has(activeEffect!);\r\n  // 这里是一个 反向收集依赖\r\n  // dep 里面 里面存的是 依赖这个响应式对象的 所有 effct\r\n  // 同时 也把这个 响应式对象 回传到 effct 里面进行存储\r\n  // 这个 effect.deps 里面存的是 所有依赖这个 effect 的响应式对象\r\n  if (!dep.has(activeEffect)) {\r\n    dep.add(activeEffect);\r\n    (activeEffect as any).deps.push(dep);\r\n  }\r\n}\r\n\r\nexport function trigger(target, type, key) {\r\n  // 1. 先收集所有的 dep 放到 deps 里面，\r\n  // 后面会统一处理\r\n  let deps: Array<any> = [];\r\n  // dep\r\n\r\n  const depsMap = targetMap.get(target);\r\n\r\n  if (!depsMap) return;\r\n\r\n  // 暂时只实现了 GET 类型\r\n  // get 类型只需要取出来就可以\r\n  const dep = depsMap.get(key);\r\n\r\n  // 最后收集到 deps 内\r\n  deps.push(dep);\r\n\r\n  const effects: Array<any> = [];\r\n  deps.forEach((dep) => {\r\n    // 这里解构 dep 得到的是 dep 内部存储的 effect\r\n    effects.push(...dep);\r\n  });\r\n  \r\n  // 这里把逻辑抽离出来 到 triggerEffects 中\r\n  // reactive 需要寻找 它需要触发的对应 key 的 依赖集合列表\r\n  // 而 ref 不需要这一步，所以 如果是 ref 调用的时候 就直接 调用 triggerEffects 就可以了\r\n  // 而 reactive 就调用 trigger 找到对应的 set 再进行 triggerEffects\r\n  triggerEffects(createDep(effects));\r\n}\r\n\r\nexport function isTracking() {\r\n  // 只有在 effect 函数执行的时候，才会执行依赖收集\r\n  // 这个地方使用 shouldTrack 这个变量来控制是否执行依赖收集\r\n  // 第一点是 如果 effect被 stop 了或者是 响应式对象使用了 ++ 操作（++操作可以拆分出2步 1步是set 1步是get）\r\n  // 第二点是 如果 响应式对象 没有依赖 只是调用了 get 方法，这个时候 get 会触发依赖收集，所以 activerEffect 本来就应该是没有值的 就跳过依赖收集\r\n  return shouldTrack && activeEffect !== undefined;\r\n}\r\n\r\nexport function triggerEffects(dep) {\r\n  // 执行收集到的所有的 effect 的 run 方法\r\n  for (const effect of dep) {\r\n    if (effect.scheduler) {\r\n      // scheduler 可以让用户自己选择调用的时机\r\n      // 这样就可以灵活的控制调用了\r\n      // 在 runtime-core 中，就是使用了 scheduler 实现了在 next ticker 中调用的逻辑\r\n      effect.scheduler();\r\n    } else {\r\n      effect.run();\r\n    }\r\n  }\r\n}\r\n","/*\r\n * @Author: hansy hanshunyao_hansy@163.com\r\n * @Date: 2025-03-07 14:56:30\r\n * @LastEditors: hansy hanshunyao_hansy@163.com\r\n * @LastEditTime: 2025-03-12 17:00:51\r\n * @FilePath: \\mini-vue\\src\\reactivity\\baseHandlers.ts\r\n * @Description: 用于生成响应式对象的 getter 和 setter\r\n */\r\nimport { track, trigger } from \"./effect\";\r\nimport {\r\n  reactive,\r\n  ReactiveFlags,\r\n  reactiveMap,\r\n  readonly,\r\n  readonlyMap,\r\n  shallowReadonlyMap,\r\n} from \"./reactive\";\r\nimport { isObject } from \"@mini-vue/shared\";\r\n\r\nconst get = createGetter();\r\nconst set = createSetter();\r\nconst readonlyGet = createGetter(true);\r\nconst shallowReadonlyGet = createGetter(true, true);\r\n\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n  return function get(target, key, receiver) {\r\n    const isExistInReactiveMap = () =>\r\n      key === ReactiveFlags.RAW && receiver === reactiveMap.get(target);\r\n\r\n    const isExistInReadonlyMap = () =>\r\n      key === ReactiveFlags.RAW && receiver === readonlyMap.get(target);\r\n\r\n    const isExistInShallowReadonlyMap = () =>\r\n      key === ReactiveFlags.RAW && receiver === shallowReadonlyMap.get(target);\r\n\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly;\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly;\r\n    } else if (\r\n      isExistInReactiveMap() ||\r\n      isExistInReadonlyMap() ||\r\n      isExistInShallowReadonlyMap()\r\n    ) {\r\n      return target;\r\n    }\r\n\r\n    const res = Reflect.get(target, key, receiver);\r\n\r\n    // readonly 不会触发 set 操作，所以也不用进行依赖收集\r\n    if (!isReadonly) {\r\n      // 在触发 get 的时候进行依赖收集\r\n      track(target, \"get\", key);\r\n    }\r\n\r\n    // 浅层的 readonly 内部对象不是响应式对象 不需要递归，直接返回\r\n    if (shallow) {\r\n      return res;\r\n    }\r\n\r\n    if (isObject(res)) {\r\n      // 如果说这个 res 值是一个对象的话，那么我们需要把获取到的 res 也转换成 reactive\r\n      // 把内部所有的是 object 的值都用 reactive 包裹，变成响应式对象\r\n      // res 等于 target[key]\r\n      // 如果 target 是只读的，那么 res 也应该是只读的\r\n      return isReadonly ? readonly(res) : reactive(res);\r\n    }\r\n\r\n    return res;\r\n  };\r\n}\r\n\r\nfunction createSetter() {\r\n  return function set(target, key, value, receiver) {\r\n    const result = Reflect.set(target, key, value, receiver);\r\n\r\n    // 在触发 set 的时候进行触发依赖\r\n    trigger(target, \"set\", key);\r\n\r\n    return result;\r\n  };\r\n}\r\n\r\nexport const readonlyHandlers = {\r\n  get: readonlyGet,\r\n  set(target, key) {\r\n    // readonly 的响应式对象不可以修改值，直接抛出警告\r\n    console.warn(\r\n      `Set operation on key \"${String(key)}\" failed: target is readonly.`,\r\n      target\r\n    );\r\n    return true;\r\n  },\r\n};\r\n\r\nexport const mutableHandlers = {\r\n  get,\r\n  set,\r\n};\r\n\r\nexport const shallowReadonlyHandlers = {\r\n  get: shallowReadonlyGet,\r\n  set(target, key) {\r\n    // readonly 的响应式对象不可以修改值\r\n    console.warn(\r\n      `Set operation on key \"${String(key)}\" failed: target is readonly.`,\r\n      target\r\n    );\r\n    return true;\r\n  },\r\n};\r\n","/*\r\n * @Author: hansy hanshunyao_hansy@163.com\r\n * @Date: 2025-03-07 14:54:23\r\n * @LastEditors: Hansy hanshunyao_hansy@163.com\r\n * @LastEditTime: 2025-03-09 18:14:57\r\n * @FilePath: \\mini-vue\\src\\reactivity\\reactive.ts\r\n * @Description: reactive 主逻辑\r\n */\r\nimport {\r\n  mutableHandlers,\r\n  readonlyHandlers,\r\n  shallowReadonlyHandlers,\r\n} from './baseHandlers';\r\n\r\nexport const reactiveMap = new WeakMap();\r\nexport const readonlyMap = new WeakMap();\r\nexport const shallowReadonlyMap = new WeakMap();\r\n\r\n// 用于判断对象的类型，这个地方提出来，提成常数类型 方便后序更改\r\n// 判断 isProxy\r\n// 判断 isReactive\r\n// 判断 isReadonly\r\n// 判断 isRaw\r\nexport const enum ReactiveFlags {\r\n  IS_REACTIVE = '__v_isReactive',\r\n  IS_READONLY = '__v_isReadonly',\r\n  RAW = '__v_raw',\r\n}\r\n\r\nexport function reactive(target) {\r\n  // createReactiveObject 提出公共方法，可以根据传入参数的不同实现 readonly 、readonly 和 shallowReadonly 功能\r\n  return createReactiveObject(target, reactiveMap, mutableHandlers);\r\n}\r\n\r\nexport function readonly(target) {\r\n  // 创建只读响应式对象\r\n  return createReactiveObject(target, readonlyMap, readonlyHandlers);\r\n}\r\n\r\nexport function shallowReadonly(target) {\r\n  // 创建 表层只读响应式对象\r\n  return createReactiveObject(\r\n    target,\r\n    shallowReadonlyMap,\r\n    shallowReadonlyHandlers\r\n  );\r\n}\r\n\r\nexport function isProxy(value) {\r\n  // 只要 是 reactive 或者 readonly 都是 proxy 对象\r\n  return isReactive(value) || isReadonly(value);\r\n}\r\n\r\nexport function isReactive(value) {\r\n  // 只要是 proxy 的话，那么会触发 get 操作\r\n  // 出发get操作就会触发 createGetter 里面的判断\r\n  // createGetter 里面增加了判断，如果 get 操作获取的 key 是当前value 查询的 的key\r\n  // 就会返回 创建 getter 的时候 传入的 isReadonly 的非值，如果不是 readonly 就证明是 reactive\r\n  // 如果这个地方不是 proxy 直接就会返回 false\r\n  return !!value[ReactiveFlags.IS_REACTIVE];\r\n}\r\n\r\nexport function isReadonly(value) {\r\n  // 与上面 isReactive 逻辑一样\r\n  // 这里面获取了特定的 key 值，如果 value 是 proxy 的话，就会触发 get\r\n  // 就会触发 createGetter 里面的判断，返回 创建 getter 时的 readonly的值\r\n  // 如果不是 proxy 直接就会返回 false\r\n  return !!value[ReactiveFlags.IS_READONLY];\r\n}\r\n\r\nexport function toRaw(value) {\r\n  // 如果 value 是 proxy 的话 ,那么直接返回就可以了\r\n  // 因为会触发 createGetter 内的逻辑\r\n  // 如果 value 是普通对象的话，\r\n  // 我们就应该返回普通对象\r\n  // 只要不是 proxy ，只要是得到了 undefined 的话，那么就一定是普通对象\r\n  if (!value[ReactiveFlags.RAW]) {\r\n    return value;\r\n  }\r\n\r\n  return value[ReactiveFlags.RAW];\r\n}\r\n\r\nfunction createReactiveObject(target, proxyMap, baseHandlers) {\r\n  // 核心就是 proxy\r\n  // 目的是可以侦听到用户 get 或者 set 的动作\r\n\r\n  // 如果命中的话就直接返回就好了\r\n  // 使用缓存做的优化点\r\n  const existingProxy = proxyMap.get(target);\r\n  if (existingProxy) {\r\n    return existingProxy;\r\n  }\r\n\r\n  const proxy = new Proxy(target, baseHandlers);\r\n\r\n  // 把创建好的 proxy 给存起来\r\n  proxyMap.set(target, proxy);\r\n  return proxy;\r\n}\r\n","/*\r\n * @Author: Hansy hanshunyao_hansy@163.com\r\n * @Date: 2025-03-08 14:42:33\r\n * @LastEditors: Hansy hanshunyao_hansy@163.com\r\n * @LastEditTime: 2025-03-09 21:59:37\r\n * @FilePath: \\mini-vue\\src\\reactivity\\ref.ts\r\n * @Description: ref 主逻辑\r\n */\r\nimport { trackEffects, triggerEffects, isTracking } from \"./effect\";\r\nimport { createDep } from \"./dep\";\r\nimport { isObject, hasChanged } from \"@mini-vue/shared\";\r\nimport { reactive } from \"./reactive\";\r\n\r\n// 这个的 ref 和 reactive 的区别就是\r\n// reactive 收集依赖是 根据 ReactiveEffect 触发的不同的 key 在dep 中储存的\r\n// 而 ref 就一个 key value 所以收集依赖的时候 就把 全局变量 activeEffect 收集到 dep 里面就可以了\r\n\r\n// 这里面 ref 的实现逻辑\r\n// 其实 ref 就是对于单值的响应式\r\n// 但是就无法像之前的 reactive 一样 使用 proxy 的方法完成\r\n// 所以这里就通过对象来包裹，这里就是用的 RefImpl 类来完成\r\n// 这个类里面有个 value 的属性 就可以绑定 set get 方法，这样的话就可以直到什么时候 依赖收集什么时候触发依赖\r\n// 这也就是为什么 我们用 ref 的时候会有 .value 这个概念\r\nexport class RefImpl {\r\n  private _rawValue: any;\r\n  private _value: any;\r\n  public dep;\r\n  public __v_isRef = true;\r\n\r\n\r\n  constructor(value) {\r\n    // 如果 传进来的 value 是一个对象的话，这个 this._value 就是 proxy 代理对象了\r\n    // 所以在 这个地方 保存一下对象原先的地址\r\n    this._rawValue = value;\r\n    // 看看value 是不是一个对象，如果是一个对象的话\r\n    // 那么需要用 reactive 包裹一下\r\n    this._value = convert(value);\r\n    this.dep = createDep();\r\n  }\r\n\r\n  get value() {\r\n    // 收集依赖\r\n    trackRefValue(this);\r\n    return this._value;\r\n  }\r\n\r\n  set value(newValue) {\r\n    // 当新的值不等于老的值的话，\r\n    // 那么才需要触发依赖\r\n\r\n    // 这里需要注意的是\r\n    // 如果 传进来的 value 是一个对象的话，这个地方要和原来的地址比 不能和代理对象比\r\n    if (hasChanged(newValue, this._rawValue)) {\r\n      // 更新值 \r\n      // 和上面同理 也得重新存一下 新的原始对象的地址\r\n      this._value = convert(newValue);\r\n      this._rawValue = newValue;\r\n      // 触发依赖\r\n      triggerRefValue(this);\r\n    }\r\n  }\r\n}\r\n\r\nexport function ref(value) {\r\n  return createRef(value);\r\n}\r\n\r\nfunction convert(value) {\r\n  // 如果是一个对象的话，那么就需要用 reactive 包裹一下\r\n  return isObject(value) ? reactive(value) : value;\r\n}\r\n\r\nfunction createRef(value) {\r\n  const refImpl = new RefImpl(value);\r\n\r\n  return refImpl;\r\n}\r\n\r\nexport function triggerRefValue(ref) {\r\n  triggerEffects(ref.dep);\r\n}\r\n\r\nexport function trackRefValue(ref) {\r\n  // 这里收集依赖 和 reactive 不同，因为 reactive 有多个 key 所以在外面有个 map 存着 key 和 依赖的对应关系\r\n  // 而 ref 只有一个 value 所以直接把 activeEffect 收集到 RefImpl 实例的 dep 里面就可以了\r\n  if (isTracking()) {\r\n    trackEffects(ref.dep);\r\n  }\r\n}\r\n\r\n// 这个函数的目的是\r\n// 帮助解构 ref\r\n// 比如在 template 中使用 ref 的时候，直接使用就可以了\r\n// 例如： const count = ref(0) -> 在 template 中使用的话 可以直接 count\r\n// 解决方案就是通过 proxy 来对 ref 做处理\r\nconst shallowUnwrapHandlers = {\r\n  get(target, key, receiver) {\r\n    // 如果里面是一个 ref 类型的话，那么就返回 .value\r\n    // 如果不是的话，那么直接返回value 就可以了\r\n    return unRef(Reflect.get(target, key, receiver));\r\n  },\r\n  set(target, key, value, receiver) {\r\n    // 如果旧的值 是一个 ref 类型的话 并且新的值 不是一个 ref 的话 就可以直接给旧的value 赋值\r\n    // 除此之外 直接替换\r\n    const oldValue = target[key];\r\n    if (isRef(oldValue) && !isRef(value)) {\r\n      return (target[key].value = value);\r\n    } else {\r\n      return Reflect.set(target, key, value, receiver);\r\n    }\r\n  },\r\n};\r\n\r\n// 这里没有处理 objectWithRefs 是 reactive 类型的时候\r\n// TODO reactive 里面如果有 ref 类型的 key 的话， 那么也是不需要调用 ref.value 的\r\n// （but 这个逻辑在 reactive 里面没有实现）\r\nexport function proxyRefs(objectWithRefs) {\r\n  return new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n}\r\n\r\n// 把 ref 里面的值拿到\r\nexport function unRef(ref) {\r\n  // 返回 ref 的值\r\n  // 如果是 ref 类型的话，那么就返回 value\r\n  // 如果不是的话，那么就返回本身\r\n  return isRef(ref) ? ref.value : ref;\r\n}\r\n\r\nexport function isRef(value) {\r\n  // 这个地方 不像 reactive 一样， reactive 里面 有 readoly 这些词 只能分开判断\r\n  // 而 ref 里面 只要有 一种状态，所以直接在构造函数中 就给这个 ref 加上一个 __v_isRef 属性就可以了\r\n  // 所以 如果是 ref ，通过 refImpl 构造函数出来的对象一定有这个属性\r\n  return !!value.__v_isRef;\r\n}\r\n","/*\r\n * @Author: hansy hanshunyao_hansy@163.com\r\n * @Date: 2025-03-07 15:39:01\r\n * @LastEditors: Hansy hanshunyao_hansy@163.com\r\n * @LastEditTime: 2025-03-09 22:22:11\r\n * @FilePath: \\mini-vue\\src\\reactivity\\computed.ts\r\n * @Description: computed 主逻辑\r\n */\r\nimport { createDep } from \"./dep\";\r\nimport { ReactiveEffect } from \"./effect\";\r\nimport { trackRefValue, triggerRefValue } from \"./ref\";\r\n\r\nexport class ComputedRefImpl {\r\n  public dep: any;\r\n  public effect: ReactiveEffect;\r\n\r\n  private _dirty: boolean;\r\n  private _value\r\n\r\n  constructor(getter) {\r\n    this._dirty = true;\r\n    this.dep = createDep();\r\n    // 这里将 用户传入的 fn 转变成一个 ReactiveEffect \r\n    // 这里 第一次 会执行 getter 后面会执行 scheduler\r\n    // 每次 依赖的响应式数据发生变化的时候，就会执行 scheduler\r\n    // 就会把 this._dirty 的开关打开 get 方法就可以重新获取数据了\r\n    this.effect = new ReactiveEffect(getter, () => {\r\n      if (this._dirty) return;\r\n      this._dirty = true;\r\n      triggerRefValue(this);\r\n    });\r\n  }\r\n\r\n  get value() {\r\n    // 收集依赖\r\n    // compouted 和 ref 的收集依赖一个道理\r\n    // 都是只有 .value 一个属性\r\n    trackRefValue(this);\r\n    // 这里就是缓存实现的核心\r\n    // 当 执行过 一次 computed 的 get 操作的时候，this._dirty 会变为 false 把 重新获取数据的方法锁上\r\n    // 当 依赖的响应式数据发生变化的时候，this._dirty 的值会变为 true 把 重新获取数据的方法解锁\r\n  // 这样就相当于 数据没改变的时候 获取的是缓存，改变了 就重新获取数据\r\n    if (this._dirty) {\r\n      this._dirty = false;\r\n      // 这里执行 run 的话，就是执行用户传入的 fn\r\n      this._value = this.effect.run();\r\n    }\r\n\r\n    return this._value;\r\n  }\r\n}\r\n\r\nexport function computed(getter) {\r\n  return new ComputedRefImpl(getter);\r\n}\r\n","import { initProps } from './componentProps';\r\nimport { initSlots } from './componentSlots';\r\nimport { emit } from './componentEmits';\r\nimport { PublicInstanceProxyHandlers } from './componentPublicInstance';\r\nimport { proxyRefs, shallowReadonly } from '@mini-vue/reactivity';\r\n\r\nexport function createComponentInstance(vnode, parent) {\r\n  const instance = {\r\n    // 这个地方 把 vnode.type 赋值给 instance.type\r\n    // 这样后面使用的时候就不用 instance.vnode.type 了\r\n    // 直接 instance.type 就可以了\r\n    type: vnode.type,\r\n    vnode,\r\n    next: null, // 需要更新的 vnode，用于更新 component 类型的组件\r\n    // 获取 parent 的 provides 作为当前组件的初始化值 这样就可以继承 parent.provides 的属性了\r\n    provides: parent ? parent.provides : {},\r\n    proxy: null,\r\n    // 组件的 attrs\r\n    attrs: {},\r\n    isMounted: false, // 是否首次挂载（初始化）\r\n    props: {},\r\n    slots: {},\r\n    parent,\r\n    ctx: {}, // context 对象\r\n    setupState: {}, // 存储 setup 的返回值\r\n    emit: () => {},\r\n  };\r\n\r\n  // 在 prod 坏境下的 ctx 只是下面简单的结构\r\n  // 在 dev 环境下会更复杂\r\n  instance.ctx = {\r\n    _: instance,\r\n  };\r\n\r\n  // 赋值 emit\r\n  // 这里使用 bind 把 instance 进行绑定\r\n  // 后面用户使用的时候只需要给 event 和参数即可\r\n  instance.emit = emit.bind(null, instance) as any;\r\n\r\n  return instance;\r\n}\r\n\r\nexport function setupComponent(instance) {\r\n  const { props, children } = instance.vnode;\r\n  // 初始化 props\r\n  // 1. 处理 参数 props\r\n  initProps(instance, props);\r\n  // 2. 处理 插槽 slot\r\n  initSlots(instance, children);\r\n  // 3. 处理调用setup 的返回值\r\n  // 初始化有状态的component\r\n  // 源码里面有两种类型的 component\r\n  // 一种是基于 options 创建的\r\n  // 还有一种是 function 的\r\n  // 这里处理的是 options 创建的\r\n  // 叫做 stateful 类型\r\n  setupStatefulComponent(instance);\r\n}\r\n\r\nfunction setupStatefulComponent(instance: any) {\r\n  console.log('创建 proxy');\r\n  // 1. 先创建代理 proxy\r\n  // 这里的空对象就是一个 ctx ，为的是访问 代理的时候直接能获取到 setupState 的属性\r\n  // 方便用户在 render 中 使用 this 就可以 访问 setup 中的属性\r\n  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);\r\n\r\n  const Component = instance.type;\r\n  // 2. 调用 setup\r\n  const { setup } = Component;\r\n  if (setup) {\r\n    // 调用 setup 方法\r\n    // 这里 setupResult 可能是 function 也可能是 object\r\n    // 如果是 function 就认为是组件的 render 函数\r\n    // 如果是 object 就把返回的对象注入到组件上下文中\r\n\r\n    // 设置当前 currentInstance 的值\r\n    // 必须要在调用 setup 之前\r\n    // 这个地方在 调用 getCurrentInstance 之前就把值保存到全局变量中\r\n    setCurrentInstance(instance);\r\n    const setupContext = createSetupContext(instance);\r\n    // 这里调用 组件中的 setup 方法 并把 props 传进去\r\n    // 这里就 可能调用了 getCurrentInstance 方法，正好上面赋值好了，这里就可以动态的拿到这个组件的实例对象\r\n    // 这样就确保了 在不同的组件 setup 中 调用都可以拿到对应的 实例对象\r\n    // 真实的处理场景里面应该是只在 dev 环境才会把 props 设置为只读的\r\n    const setupResult =\r\n      setup && setup(shallowReadonly(instance.props), setupContext);\r\n    // 这里调用完 setup 方法后，就把全局变量的值清空\r\n    setCurrentInstance(null);\r\n    // 3. 处理 setupResult\r\n    handleSetupResult(instance, setupResult);\r\n  } else {\r\n    finishComponentSetup(instance);\r\n  }\r\n}\r\n\r\nfunction createSetupContext(instance) {\r\n  console.log('初始化 setup context');\r\n  return {\r\n    attrs: instance.attrs,\r\n    slots: instance.slots,\r\n    emit: instance.emit,\r\n    expose: () => {}, // TODO 实现 expose 函数逻辑\r\n  };\r\n}\r\n\r\nfunction handleSetupResult(instance: any, setupResult: any) {\r\n  // setup 返回值不一样的话，会有不同的处理\r\n  // 1. 看看 setupResult 是个什么\r\n  if (typeof setupResult === 'function') {\r\n    // 如果返回的是 function 的话，那么绑定到 render 上\r\n    // 认为是 render 逻辑\r\n    // setup(){ return ()=>(h(\"div\")) }\r\n    instance.render = setupResult;\r\n  } else if (typeof setupResult === 'object') {\r\n    // 返回的是一个对象的话\r\n    // 先存到 setupState 上\r\n    // 先使用 @vue/reactivity 里面的 proxyRefs\r\n    // 后面我们自己构建\r\n    // proxyRefs 的作用就是把 setupResult 对象做一层代理\r\n    // 方便用户直接访问 ref 类型的值\r\n    // 比如 setupResult 里面有个 count 是个 ref 类型的对象，用户使用的时候就可以直接使用 count 了，而不需要在 count.value\r\n    // 这里也就是官网里面说到的自动结构 Ref 类型\r\n    instance.setupState = proxyRefs(setupResult);\r\n  }\r\n  finishComponentSetup(instance);\r\n}\r\n\r\nfunction finishComponentSetup(instance: any) {\r\n  // 给 instance 设置 render\r\n\r\n  // 先取到用户设置的 component options\r\n  const Component = instance.type;\r\n\r\n  if (!instance.render) {\r\n    // 这里的 compile 是编译器，将模板渲染为 render 函数\r\n    // 如果 compile 有值 并且当组件没有 render 函数\r\n    // 那么就需要把 template 编译成 render 函数\r\n    if (compile && !Component.render) {\r\n      if (Component.template) {\r\n        // 这里就是 runtime 模块和 compile 模块结合点\r\n        const template = Component.template;\r\n        Component.render = compile(template);\r\n      }\r\n    }\r\n\r\n    instance.render = Component.render;\r\n  }\r\n}\r\n\r\nlet currentInstance = {};\r\n// 这个接口暴露给用户，用户可以在 setup 中获取组件实例 instance\r\nexport function getCurrentInstance(): any {\r\n  return currentInstance;\r\n}\r\n\r\nexport function setCurrentInstance(instance) {\r\n  // 这个地方 把 赋值操作提取出来了，为的是 以后如果想看 这个变量的赋值情况，就在这个地方打上断点就可以方便调试\r\n  // 这个地方也起到了中间层的作用，如果后面多处调用了 赋值操作，如果没有抽象出来方法的话，不好找寻是哪出赋值的\r\n  // 这样把这个提取出来后，只需要在这里打上断点就可以通过 event 事件栈来看到是谁调用的\r\n  currentInstance = instance;\r\n}\r\n\r\nlet compile;\r\nexport function registerRuntimeCompiler(_compile) {\r\n  // 把 compile 挂在到全局变量\r\n  compile = _compile;\r\n}\r\n","import { getCurrentInstance } from \"./component\";\n\nexport function provide(key, value) {\n  // 获取 执行 setup 前存的 全局变量 这个是当前组件的 instance 实例\n  const currentInstance = getCurrentInstance();\n\n  if (currentInstance) {\n    // 获取当前组件的 provides\n    let { provides } = currentInstance;\n    // 获取当前组件的父级组件的 provides\n    const parentProvides = currentInstance.parent?.provides;\n\n    // 这里要解决一个问题\n    // 当父级 key 和 爷爷级别的 key 重复的时候，对于子组件来讲，需要取最近的父级别组件的值\n    // 那这里的解决方案就是利用原型链来解决\n    // provides 初始化的时候是在 createComponent 时处理的，当时是直接把 parent.provides 赋值给组件的 provides 的\n    // 所以，如果说这里发现 provides 和 parentProvides 相等的话，那么就说明是第一次做 provide(对于当前组件来讲)\n    // 我们就可以把 parent.provides 作为 currentInstance.provides 的原型重新赋值\n    // 至于为什么不在 createComponent 的时候做这个处理，可能的好处是在这里初始化的话，是有个懒执行的效果（优化点，只有需要的时候在初始化）\n    if (parentProvides === provides) {\n      // 这个地方借用了原型链的特性，如果 改写了 子的实现 是不会改写父的方法的\n      // 如果子上没有这个方法，会去父上找\n      provides = currentInstance.provides = Object.create(parentProvides);\n    }\n\n    // 赋值\n    provides[key] = value;\n  }\n}\n\nexport function inject(key, defaultValue) {\n  const currentInstance = getCurrentInstance();\n  if (currentInstance) {\n    const provides = currentInstance.parent?.provides;\n\n    // 如果找到值了就返回值\n    // 如果没找到就看有没有传默认值，传了就返回默认值\n    if (key in provides) {\n      return provides[key];\n    } else if (defaultValue) {\n      // 如果是函数就执行函数 返回函数返回值\n      // 否则就直接返回\n      if (typeof defaultValue === \"function\") {\n        return defaultValue();\n      }\n      return defaultValue;\n    }\n  }\n}\n","import { createVNode, Fragment } from \"../vnode\";\r\n\r\n/**\r\n * Compiler runtime helper for rendering `<slot/>`\r\n * 用来 render slot 的\r\n * 之前是把 slot 的数据都存在 instance.slots 内(可以看 componentSlot.ts)，\r\n * 这里就是取数据然后渲染出来的点\r\n * 这个是由 compiler 模块直接渲染出来的 -可以参看这个 demo https://vue-next-template-explorer.netlify.app/#%7B%22src%22%3A%22%3Cdiv%3E%5Cn%20%20%3Cslot%3E%3C%2Fslot%3E%5Cn%3C%2Fdiv%3E%22%2C%22ssr%22%3Afalse%2C%22options%22%3A%7B%22mode%22%3A%22module%22%2C%22prefixIdentifiers%22%3Afalse%2C%22optimizeImports%22%3Afalse%2C%22hoistStatic%22%3Afalse%2C%22cacheHandlers%22%3Afalse%2C%22scopeId%22%3Anull%2C%22inline%22%3Afalse%2C%22ssrCssVars%22%3A%22%7B%20color%20%7D%22%2C%22bindingMetadata%22%3A%7B%22TestComponent%22%3A%22setup-const%22%2C%22setupRef%22%3A%22setup-ref%22%2C%22setupConst%22%3A%22setup-const%22%2C%22setupLet%22%3A%22setup-let%22%2C%22setupMaybeRef%22%3A%22setup-maybe-ref%22%2C%22setupProp%22%3A%22props%22%2C%22vMySetupDir%22%3A%22setup-const%22%7D%2C%22optimizeBindings%22%3Afalse%7D%7D\r\n * 其最终目的就是在 render 函数中调用 renderSlot 取 instance.slots 内的数据\r\n * TODO 这里应该是一个返回一个 block ,但是暂时还没有支持 block ，所以这个暂时只需要返回一个 vnode 即可\r\n * 因为 block 的本质就是返回一个 vnode\r\n *\r\n * @private\r\n */\r\nexport function renderSlot(slots, name: string, props = {}) {\r\n  // 这个地方 slots 就是  renderSlot(this.$slots, 'body'), 中 的 this.$slots，也就是 父组件的 slots\r\n  // name 是 子组件 插槽的 key\r\n  // 根据子组件 的插槽 key，去 父组件 中取对应的插槽数据 创建虚拟节点并返回\r\n  const slot = slots[name];\r\n  console.log(`渲染插槽 slot -> ${name}`);\r\n  if (slot) {\r\n    // 因为 slot 是一个返回 vnode 的函数，我们只需要把这个结果返回出去即可\r\n    // slot 就是一个函数，所以就可以把当前组件的一些数据给传出去，这个就是作用域插槽\r\n    // 参数就是 props\r\n    const slotContent = slot(props);\r\n\r\n    // 这个 Fragment 是一个特殊标识， 在 patch 的时候 有判断， 如果 遇到这个表示，就挂载它的 children 即可\r\n    // Fragment 用的是 使用 symbol\r\n    return createVNode(Fragment, {}, slotContent);\r\n  }\r\n}\r\n","const queue: any[] = [];\nconst activePreFlushCbs: any = [];\n\nconst p = Promise.resolve();\nlet isFlushPending = false;\n\nexport function nextTick(fn?) {\n  return fn ? p.then(fn) : p;\n}\n\nexport function queueJob(job) {\n  if (!queue.includes(job)) {\n    queue.push(job);\n    // 执行所有的 job\n    queueFlush();\n  }\n}\n\nfunction queueFlush() {\n  // 如果同时触发了两个组件的更新的话\n  // 这里就会触发两次 then （微任务逻辑）\n  // 但是着是没有必要的\n  // 我们只需要触发一次即可处理完所有的 job 调用\n  // 所以需要判断一下 如果已经触发过 nextTick 了\n  // 那么后面就不需要再次触发一次 nextTick 逻辑了\n  if (isFlushPending) return;\n  isFlushPending = true;\n  nextTick(flushJobs);\n}\n\nexport function queuePreFlushCb(cb) {\n  queueCb(cb, activePreFlushCbs);\n}\n\nfunction queueCb(cb, activeQueue) {\n  // 直接添加到对应的列表内就ok\n  // todo 这里没有考虑 activeQueue 是否已经存在 cb 的情况\n  // 然后在执行 flushJobs 的时候就可以调用 activeQueue 了\n  activeQueue.push(cb);\n\n  // 然后执行队列里面所有的 job\n  queueFlush()\n}\n\nfunction flushJobs() {\n  isFlushPending = false;\n\n  // 先执行 pre 类型的 job\n  // 所以这里执行的job 是在渲染前的\n  // 也就意味着执行这里的 job 的时候 页面还没有渲染\n  flushPreFlushCbs();\n\n  // 这里是执行 queueJob 的\n  // 比如 render 渲染就是属于这个类型的 job\n  let job;\n  while ((job = queue.shift())) {\n    if (job) {\n      job();\n    }\n  }\n}\n\nfunction flushPreFlushCbs() {\n  // 执行所有的 pre 类型的 job\n  for (let i = 0; i < activePreFlushCbs.length; i++) {\n    activePreFlushCbs[i]();\n  }\n}\n","export function shouldUpdateComponent(prevVNode, nextVNode) {\n  const { props: prevProps } = prevVNode;\n  const { props: nextProps } = nextVNode;\n  //   const emits = component!.emitsOptions;\n\n  // 这里主要是检测组件的 props\n  // 核心：只要是 props 发生改变了，那么这个 component 就需要更新\n\n  // 1. props 没有变化，那么不需要更新组件 就只更新 element 就可以了\n  if (prevProps === nextProps) {\n    return false;\n  }\n  // 如果之前没有 props，那么就需要看看现在有没有 props 了\n  // 所以这里基于 nextProps 的值来决定是否更新\n  if (!prevProps) {\n    return !!nextProps;\n  }\n  // 之前有值，现在没值，那么肯定需要更新\n  if (!nextProps) {\n    return true;\n  }\n\n  // 以上都是比较明显的可以知道 props 是否是变化的\n  // 在 hasPropsChanged 会做更细致的对比检测\n  return hasPropsChanged(prevProps, nextProps);\n}\n\nfunction hasPropsChanged(prevProps, nextProps): boolean {\n  // 依次对比每一个 props.key\n\n  // 提前对比一下 length ，length 不一致肯定是需要更新的\n  const nextKeys = Object.keys(nextProps);\n  if (nextKeys.length !== Object.keys(prevProps).length) {\n    return true;\n  }\n\n  // 只要现在的 prop 和之前的 prop 不一样那么就需要更新\n  for (let i = 0; i < nextKeys.length; i++) {\n    const key = nextKeys[i];\n    if (nextProps[key] !== prevProps[key]) {\n      return true;\n    }\n  }\n  return false;\n}\n","import { ShapeFlags } from \"@mini-vue/shared\";\nimport { createComponentInstance } from \"./component\";\nimport { queueJob } from \"./scheduler\";\nimport { effect } from \"@mini-vue/reactivity\";\nimport { setupComponent } from \"./component\";\nimport { Fragment, normalizeVNode, Text } from \"./vnode\";\nimport { shouldUpdateComponent } from \"./componentRenderUtils\";\nimport { createAppAPI } from \"./createApp\";\n\nexport function createRenderer(options) {\n  const {\n    createElement: hostCreateElement,\n    setElementText: hostSetElementText,\n    patchProp: hostPatchProp,\n    insert: hostInsert,\n    remove: hostRemove,\n    setText: hostSetText,\n    createText: hostCreateText,\n  } = options;\n\n  function render(vnode, container) {\n    // 调用 patch\n    // 后续方便递归\n    console.log('调用 patch');\n    // 初始化 第一次 没有 n1 也就是没有 上次的节点，只有 n2 新节点\n    patch(null, vnode, container);\n  }\n\n  function patch(\n    n1,\n    n2,\n    container = null,\n    anchor = null,\n    parentComponent = null\n  ) {\n    // TODO：这个地方需要是初始化还是 update\n    // 现在是直接处理 初始化\n    // 后续会处理 update\n\n    // 基于 n2 的类型来判断\n    // 因为 n2 是新的 vnode\n    const { type, shapeFlag } = n2;\n    // 这个地方使用 与的操作，与的特点是 都是1 ，结果才是 1，只要有一个是 0 ，结果就是 0\n    // ShapeFlags 中的类型 在其算表示的位上 为 1 其他位都是0 ，所以 只要是 这个 虚拟节点的该位上 为1 就返回有值，如果虚拟节点这位不是 1 那整个结果都是 0\n    switch (type) {\n      case Text:\n        processText(n1, n2, container);\n        break;\n      // 其中还有几个类型比如： static fragment comment\n      case Fragment:\n        processFragment(n1, n2, container);\n        break;\n      default:\n        // 这里就基于 shapeFlag 来处理\n        if (shapeFlag & ShapeFlags.ELEMENT) {\n          console.log('处理 element');\n          processElement(n1, n2, container, anchor, parentComponent);\n        } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\n          console.log('处理 component');\n          processComponent(n1, n2, container, parentComponent);\n        }\n    }\n  }\n\n  function processFragment(n1: any, n2: any, container: any) {\n    // 只需要渲染 children ，然后给添加到 container 内\n    if (!n1) {\n      // 初始化 Fragment 逻辑点\n      console.log('初始化 Fragment 类型的节点');\n      mountChildren(n2.children, container);\n    }\n  }\n\n  function processText(n1, n2, container) {\n    console.log('处理 Text 节点');\n    if (n1 === null) {\n      // n1 是 null 说明是 init 的阶段\n      // 基于 createText 创建出 text 节点，然后使用 insert 添加到 el 内\n      console.log('初始化 Text 类型的节点');\n      hostInsert((n2.el = hostCreateText(n2.children as string)), container);\n    } else {\n      // update\n      // 先对比一下 updated 之后的内容是否和之前的不一样\n      // 在不一样的时候才需要 update text\n      // 这里抽离出来的接口是 setText\n      // 注意，这里一定要记得把 n1.el 赋值给 n2.el, 不然后续是找不到值的\n      const el = (n2.el = n1.el!);\n      if (n2.children !== n1.children) {\n        console.log('更新 Text 类型的节点');\n        hostSetText(el, n2.children as string);\n      }\n    }\n  }\n\n  function processElement(n1, n2, container, anchor, parentComponent) {\n    if (!n1) {\n      // 初始化挂载 element\n      mountElement(n2, container, anchor);\n    } else {\n      // 更新 element 元素\n      updateElement(n1, n2, container, anchor, parentComponent);\n    }\n  }\n\n  function updateElement(n1, n2, container, anchor, parentComponent) {\n    const oldProps = (n1 && n1.props) || {};\n    const newProps = n2.props || {};\n    // 应该更新 element\n    console.log('应该更新 element');\n    console.log('旧的 vnode', n1);\n    console.log('新的 vnode', n2);\n\n    // 需要把 el 挂载到新的 vnode\n    const el = (n2.el = n1.el);\n\n    // 对比 props\n    patchProps(el, oldProps, newProps);\n\n    // 对比 children\n    patchChildren(n1, n2, el, anchor, parentComponent);\n  }\n\n  function patchProps(el, oldProps, newProps) {\n    // 对比 props 有以下几种情况\n    // 1. oldProps 有，newProps 也有，但是 val 值变更了\n    // 例如下面的情况\n    // 之前: oldProps.id = 1 ，更新后：newProps.id = 2\n\n    // key 存在 oldProps 里 也存在 newProps 内\n    // 以 newProps 作为基准\n    for (const key in newProps) {\n      const prevProp = oldProps[key];\n      const nextProp = newProps[key];\n      if (prevProp !== nextProp) {\n        // 对比属性\n        // 需要交给 host 来更新 key\n\n        // hostPatchProp 中还处理了一种情况，如果 nextProp 是 null 的话\n        // 那么就需要把之前的属性给删除掉 removeAttribute\n        // 如果不为空 就 setAttribute\n        hostPatchProp(el, key, prevProp, nextProp);\n      }\n    }\n\n    // 2. oldProps 有，而 newProps 没有了\n    // 之前： {id:1,tId:2}  更新后： {id:1}\n    // 这种情况下我们就应该以 oldProps 作为基准，因为在 newProps 里面是没有的 tId 的\n    // 还需要注意一点，如果这个 key 在 newProps 里面已经存在了，说明已经处理过了，就不要在处理了\n    for (const key in oldProps) {\n      const prevProp = oldProps[key];\n      const nextProp = null;\n      if (!(key in newProps)) {\n        // 这里是以 oldProps 为基准来遍历，\n        // 而且得到的值是 newProps 内没有的\n        // 所以交给 host 更新的时候，把新的值设置为 null 就触发了里面的判断 removeAttribute\n        hostPatchProp(el, key, prevProp, nextProp);\n      }\n    }\n  }\n\n  function patchChildren(n1, n2, container, anchor, parentComponent) {\n    const { shapeFlag: prevShapeFlag, children: c1 } = n1;\n    const { shapeFlag, children: c2 } = n2;\n\n    // 如果 n2 的 children 是 text 类型的话\n    // 就看看和之前的 n1 的 children 是不是一样的\n    // 如果不一样的话直接重新设置一下 text 即可\n    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n      if (c2 !== c1) {\n        console.log('类型为 text_children, 当前需要更新');\n        hostSetElementText(container, c2 as string);\n      }\n    } else {\n      // 看看之前的是不是 text\n      if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {\n        // 先清空\n        // 然后在把新的 children 给 mount 生成 element\n        hostSetElementText(container, '');\n        mountChildren(c2, container);\n      } else {\n        // array diff array\n        // 如果之前是 array_children\n        // 现在还是 array_children 的话\n        // 那么就需要对比两个 children\n        patchKeyedChildren(c1, c2, container, parentComponent, anchor);\n      }\n    }\n  }\n\n  function patchKeyedChildren(\n    c1: any[],\n    c2: any[],\n    container,\n    parentAnchor,\n    parentComponent\n  ) {\n    // i 就是左指针，对比两个 children 从左往右\n    // e1 就是旧的 array 右指针\n    // e2 就是新的 array 右指针\n    let i = 0;\n    const l2 = c2.length;\n    let e1 = c1.length - 1;\n    let e2 = l2 - 1;\n\n    const isSameVNodeType = (n1, n2) => {\n      return n1.type === n2.type && n1.key === n2.key;\n    };\n\n    // 此处是左端对比\n    // i 不能超过两个右指针的位置\n    // 不然会出现空指针\n    while (i <= e1 && i <= e2) {\n      const prevChild = c1[i];\n      const nextChild = c2[i];\n\n      if (!isSameVNodeType(prevChild, nextChild)) {\n        // 当新旧两个 child 元素不相等了 退出循环\n        console.log('两个 child 不相等(从左往右比对)');\n        console.log(`prevChild:${prevChild}`);\n        console.log(`nextChild:${nextChild}`);\n        break;\n      }\n\n      // 如果两个 child 一直相等 指针往后移\n      // 同时递归的去对比 child 里面的属性和 children\n      // i 右移\n      console.log('两个 child 相等，接下来对比这两个 child 节点(从左往右比对)');\n      patch(prevChild, nextChild, container, parentAnchor, parentComponent);\n      i++;\n    }\n\n    // 此处是右端对比\n    // e1 和 e2 一起右移\n    // 不能超过 i 的位置，不然会出现空指针\n    // 也大于等于 0\n    while (i <= e1 && i <= e2) {\n      // 从右向左取值\n      const prevChild = c1[e1];\n      const nextChild = c2[e2];\n\n       // 当新旧两个 child 元素不相等了 退出循环\n      if (!isSameVNodeType(prevChild, nextChild)) {\n        console.log('两个 child 不相等(从右往左比对)');\n        console.log(`prevChild:${prevChild}`);\n        console.log(`nextChild:${nextChild}`);\n        break;\n      }\n      // 如果两个 child 一直相等 指针往后移\n      // 同时递归的去对比 child 里面的属性和 children\n      // e1 e2 左移\n      console.log('两个 child 相等，接下来对比这两个 child 节点(从右往左比对)');\n      patch(prevChild, nextChild, container, parentAnchor, parentComponent);\n      e1--;\n      e2--;\n    }\n\n    if (i > e1 && i <= e2) {\n      // 如果是这种情况的话就说明 e2 也就是新节点的数量大于旧节点的数量\n      // 也就是说新增了 vnode\n      // 应该循环 c2\n      // 锚点的计算：新的节点有可能需要添加到尾部，也可能添加到头部，所以需要指定添加的问题\n      // 要添加的位置是当前的位置(e2 开始)+1\n      // 因为对于往左侧添加的话，应该获取到 c2 的第一个元素\n      // 所以我们需要从 e2 + 1 取到锚点的位置\n      const nextPos = e2 + 1;\n      // 这个地方判断 新的节点是多在 旧的左侧还是右侧\n      // 如果是在左侧的话，那么锚点就是 c2 的第一个元素\n      // 如果是在右侧的话，那么锚点就是 parentAnchor\n      const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\n      while (i <= e2) {\n        console.log(`需要新创建一个 vnode: ${c2[i].key}`);\n        patch(null, c2[i], container, anchor, parentComponent);\n        i++;\n      }\n    } else if (i > e2 && i <= e1) {\n      // 这种情况的话说明新节点的数量是小于旧节点的数量的\n      // 那么我们就需要把多余的节点删除\n      while (i <= e1) {\n        console.log(`需要删除当前的 vnode: ${c1[i].key}`);\n        hostRemove(c1[i].el);\n        i++;\n      }\n    } else {\n      // 左右两边都比对完了，然后剩下的就是中间部位顺序变动的\n      // 例如下面的情况\n      // a,b,[c,d,e],f,g\n      // a,b,[e,c,d],f,g\n\n      let s1 = i;\n      let s2 = i;\n      const keyToNewIndexMap = new Map();\n      let moved = false;\n      let maxNewIndexSoFar = 0;\n      // 先把 key 和 newIndex 绑定好，方便后续基于 key 找到 newIndex\n      // 时间复杂度是 O(1)\n      for (let i = s2; i <= e2; i++) {\n        const nextChild = c2[i];\n        keyToNewIndexMap.set(nextChild.key, i);\n      }\n\n      // 需要处理新节点的数量\n      const toBePatched = e2 - s2 + 1;\n      let patched = 0;\n      // 初始化 从新的index映射为老的index\n      // 创建数组的时候给定数组的长度，这个是性能最快的写法\n      const newIndexToOldIndexMap = new Array(toBePatched);\n      // 初始化为 0 , 后面处理的时候 如果发现是 0 的话，那么就说明新值在老的里面不存在\n      for (let i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;\n\n      // 遍历老节点\n      // 1. 需要找出老节点有，而新节点没有的 -> 需要把这个节点删除掉\n      // 2. 新老节点都有的，—> 需要 patch\n      for (i = s1; i <= e1; i++) {\n        const prevChild = c1[i];\n\n        // 优化点\n        // 如果老的节点大于新节点的数量的话，那么这里在处理老节点的时候就直接删除即可\n        if (patched >= toBePatched) {\n          hostRemove(prevChild.el);\n          continue;\n        }\n\n        let newIndex;\n        if (prevChild.key != null) {\n          // 这里就可以通过key快速的查找了， 看看在新的里面这个节点存在不存在\n          // 时间复杂度O(1)\n          newIndex = keyToNewIndexMap.get(prevChild.key);\n        } else {\n          // 如果没key 的话，那么只能是遍历所有的新节点来确定当前节点存在不存在了\n          // 时间复杂度O(n)\n          for (let j = s2; j <= e2; j++) {\n            if (isSameVNodeType(prevChild, c2[j])) {\n              newIndex = j;\n              break;\n            }\n          }\n        }\n\n        // 因为有可能 nextIndex 的值为0（0也是正常值）\n        // 所以需要通过值是不是 undefined 或者 null 来判断\n        if (newIndex === undefined) {\n          // 当前节点的key 不存在于 newChildren 中，需要把当前节点给删除掉\n          hostRemove(prevChild.el);\n        } else {\n          // 新老节点都存在\n          console.log('新老节点都存在');\n          // 把新节点的索引和老的节点的索引建立映射关系\n          // i + 1 是因为 i 有可能是0 (0 的话会被认为新节点在老的节点中不存在)\n          newIndexToOldIndexMap[newIndex - s2] = i + 1;\n          // 来确定中间的节点是不是需要移动\n          // 新的 newIndex 如果一直是升序的话，那么就说明没有移动\n          // 所以我们可以记录最后一个节点在新的里面的索引，然后看看是不是升序\n          // 不是升序的话，我们就可以确定节点移动过了\n          if (newIndex >= maxNewIndexSoFar) {\n            maxNewIndexSoFar = newIndex;\n          } else {\n            moved = true;\n          }\n\n          patch(prevChild, c2[newIndex], container, null, parentComponent);\n          patched++;\n        }\n      }\n\n      // 利用最长递增子序列来优化移动逻辑\n      // 因为元素是升序的话，那么这些元素就是不需要移动的\n      // 而我们就可以通过最长递增子序列来获取到升序的列表\n      // 在移动的时候我们去对比这个列表，如果对比上的话，就说明当前元素不需要移动\n      // 通过 moved 来进行优化，如果没有移动过的话 那么就不需要执行算法\n      // getSequence 返回的是 newIndexToOldIndexMap 的索引值\n      // 所以后面我们可以直接遍历索引值来处理，也就是直接使用 toBePatched 即可\n      const increasingNewIndexSequence = moved\n        ? getSequence(newIndexToOldIndexMap)\n        : [];\n      let j = increasingNewIndexSequence.length - 1;\n\n      // 遍历新节点\n      // 1. 需要找出老节点没有，而新节点有的 -> 需要把这个节点创建\n      // 2. 最后需要移动一下位置，比如 [c,d,e] -> [e,c,d]\n\n      // 这里倒循环是因为在 insert 的时候，需要保证锚点是处理完的节点（也就是已经确定位置了）\n      // 因为 insert 逻辑是使用的 insertBefore()\n      for (let i = toBePatched - 1; i >= 0; i--) {\n        // 确定当前要处理的节点索引\n        const nextIndex = s2 + i;\n        const nextChild = c2[nextIndex];\n        // 锚点等于当前节点索引+1\n        // 也就是当前节点的后面一个节点(又因为是倒遍历，所以锚点是位置确定的节点)\n        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\n\n        if (newIndexToOldIndexMap[i] === 0) {\n          // 说明新节点在老的里面不存在\n          // 需要创建\n          patch(null, nextChild, container, anchor, parentComponent);\n        } else if (moved) {\n          // 需要移动\n          // 1. j 已经没有了 说明剩下的都需要移动了\n          // 2. 最长子序列里面的值和当前的值匹配不上， 说明当前元素需要移动\n          if (j < 0 || increasingNewIndexSequence[j] !== i) {\n            // 移动的话使用 insert 即可\n            hostInsert(nextChild.el, container, anchor);\n          } else {\n            // 这里就是命中了  index 和 最长递增子序列的值\n            // 所以可以移动指针了\n            j--;\n          }\n        }\n      }\n    }\n  }\n\n  function mountElement(vnode, container, anchor) {\n    const { shapeFlag, props } = vnode;\n    // 1. 先创建 element\n    // 基于可扩展的渲染 api\n    const el = (vnode.el = hostCreateElement(vnode.type));\n\n    // 支持单子组件和多子组件的创建\n    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n      // 举个栗子\n      // render(){\n      //     return h(\"div\",{},\"test\")\n      // }\n      // 这里 children 就是 test ，只需要渲染一下就完事了\n      console.log(`处理文本:${vnode.children}`);\n      hostSetElementText(el, vnode.children);\n    } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n      // 举个栗子\n      // render(){\n      // Hello 是个 component\n      //     return h(\"div\",{},[h(\"p\"),h(Hello)])\n      // }\n      // 这里 children 就是个数组了，就需要依次调用 patch 递归来处理\n      mountChildren(vnode.children, el);\n    }\n\n    // 处理 props\n    if (props) {\n      for (const key in props) {\n        // todo\n        // 需要过滤掉vue自身用的key\n        // 比如生命周期相关的 key: beforeMount、mounted\n        const nextVal = props[key];\n        hostPatchProp(el, key, null, nextVal);\n      }\n    }\n\n    // todo\n    // 触发 beforeMount() 钩子\n    console.log('vnodeHook  -> onVnodeBeforeMount');\n    console.log('DirectiveHook  -> beforeMount');\n    console.log('transition  -> beforeEnter');\n\n    // 插入\n    hostInsert(el, container, anchor);\n\n    // todo\n    // 触发 mounted() 钩子\n    console.log('vnodeHook  -> onVnodeMounted');\n    console.log('DirectiveHook  -> mounted');\n    console.log('transition  -> enter');\n  }\n\n  function mountChildren(children, container) {\n    children.forEach((VNodeChild) => {\n      // todo\n      // 这里应该需要处理一下 vnodeChild\n      // 因为有可能不是 vnode 类型\n      console.log('mountChildren:', VNodeChild);\n      patch(null, VNodeChild, container);\n    });\n  }\n\n  function processComponent(n1, n2, container, parentComponent) {\n    // 如果 n1 没有值的话，那么就是 mount\n    if (!n1) {\n      // 初始化 component\n      mountComponent(n2, container, parentComponent);\n    } else {\n      updateComponent(n1, n2, container);\n    }\n  }\n\n  // 组件的更新\n  function updateComponent(n1, n2, container) {\n    console.log('更新组件', n1, n2);\n    // 更新组件实例引用\n    const instance = (n2.component = n1.component);\n    // 先看看这个组件是否应该更新\n    if (shouldUpdateComponent(n1, n2)) {\n      console.log(`组件需要更新: ${instance}`);\n      // 那么 next 就是新的 vnode 了（也就是 n2）\n      instance.next = n2;\n      // 这里的 update 是在 setupRenderEffect 里面初始化的，update 函数除了当内部的响应式对象发生改变的时候会调用\n      // 还可以直接主动的调用(这是属于 effect 的特性)\n      // 调用 update 再次更新调用 patch 逻辑\n      // 在update 中调用的 next 就变成了 n2了\n      // ps：可以详细的看看 update 中 next 的应用\n      // TODO 需要在 update 中处理支持 next 的逻辑\n      instance.update();\n    } else {\n      console.log(`组件不需要更新: ${instance}`);\n      // 不需要更新的话，那么只需要覆盖下面的属性即可\n      n2.component = n1.component;\n      n2.el = n1.el;\n      instance.vnode = n2;\n    }\n  }\n\n  function mountComponent(initialVNode: any, container: any, parentComponent) {\n    // 初始化组件\n    console.log('初始化组件');\n    // 1. 先创建一个 component instance\n    // 通过虚拟节点 创建出 组件实例对象\n    // 后面组件的所有属性都可以挂在到这个 实例对象上\n    const instance = (initialVNode.component = createComponentInstance(\n      initialVNode,\n      parentComponent\n    ));\n\n    console.log(`创建组件实例:${instance.type.name}`);\n\n    // 2. 给 instance 加工加工\n    // 处理组件的 setup\n    // setupComponent 处理3件事\n    // (1)处理 参数 props\n    // (2)处理 插槽 slot\n    // (3)处理 执行 setup 返回的值 挂载到实例上，并确保 组件有 render方法\n    setupComponent(instance);\n\n    // 在 setupComponent 中处理完 setup 并确认 render 函数存在后\n    // 该调用 render 函数来生成 虚拟 dom 树\n    setupRenderEffect(instance, initialVNode, container);\n  }\n\n  function setupRenderEffect(instance, initialVNode, container) {\n    // 调用 render\n    // 应该传入 ctx 也就是 proxy\n    // ctx 可以选择暴露给用户的 api\n    // 源代码里面是调用的 renderComponentRoot 函数\n    // 这里为了简化直接调用 render\n\n    // obj.name  = \"111\"\n    // obj.name = \"2222\"\n    // 从哪里做一些事\n    // 收集数据改变之后要做的事 (函数)\n    // 依赖收集   effect 函数\n    // 触发依赖\n    function componentUpdateFn() {\n      if (!instance.isMounted) {\n        // 组件初始化的时候会执行这里\n        // 为什么要在这里调用 render 函数呢\n        // 是因为在 effect 内调用 render 才能触发依赖收集\n        // 等到后面响应式的值变更后会再次触发这个函数\n        console.log(`${instance.type.name}:调用 render,获取 subTree`);\n        const proxyToUse = instance.proxy;\n        // 可在 render 函数中通过 this 来使用 proxy\n        const subTree = (instance.subTree = normalizeVNode(\n          instance.render.call(proxyToUse, proxyToUse)\n        ));\n        console.log('subTree', subTree);\n\n        // todo\n        console.log(`${instance.type.name}:触发 beforeMount hook`);\n        console.log(`${instance.type.name}:触发 onVnodeBeforeMount hook`);\n\n        // 这里基于 subTree 再次调用 patch\n        // 基于 render 返回的 vnode ，再次进行渲染\n        // 这里我把这个行为隐喻成开箱\n        // 一个组件就是一个箱子\n        // 里面有可能是 element （也就是可以直接渲染的）\n        // 也有可能还是 component\n        // 这里就是递归的开箱\n        // 而 subTree 就是当前的这个箱子（组件）装的东西\n        // 箱子（组件）只是个概念，它实际是不需要渲染的\n        // 要渲染的是箱子里面的 subTree\n        patch(null, subTree, container, null, instance);\n        // 把 root element 赋值给 组件的vnode.el ，为后续调用 $el 的时候获取值\n        initialVNode.el = subTree.el;\n\n        console.log(`${instance.type.name}:触发 mounted hook`);\n        instance.isMounted = true;\n      } else {\n        // 响应式的值变更后会从这里执行逻辑\n        // 主要就是拿到新的 vnode ，然后和之前的 vnode 进行对比\n        console.log(`${instance.type.name}:调用更新逻辑`);\n        // 拿到最新的 subTree\n        const { next, vnode } = instance;\n\n        // 如果有 next 的话， 说明需要更新组件的数据（props，slots 等）\n        // 先更新组件的数据，然后更新完成后，在继续对比当前组件的子元素\n        if (next) {\n          // 问题是 next 和 vnode 的区别是什么\n          next.el = vnode.el;\n          updateComponentPreRender(instance, next);\n        }\n\n        const proxyToUse = instance.proxy;\n        const nextTree = normalizeVNode(\n          instance.render.call(proxyToUse, proxyToUse)\n        );\n        // 替换之前的 subTree\n        const prevTree = instance.subTree;\n        instance.subTree = nextTree;\n\n        // 触发 beforeUpdated hook\n        console.log(`${instance.type.name}:触发 beforeUpdated hook`);\n        console.log(`${instance.type.name}:触发 onVnodeBeforeUpdate hook`);\n\n        // 用旧的 vnode 和新的 vnode 交给 patch 来处理\n        patch(prevTree, nextTree, prevTree.el, null, instance);\n\n        // 触发 updated hook\n        console.log(`${instance.type.name}:触发 updated hook`);\n        console.log(`${instance.type.name}:触发 onVnodeUpdated hook`);\n      }\n    }\n\n    // 在 vue3.2 版本里面是使用的 new ReactiveEffect\n    // 至于为什么不直接用 effect ，是因为需要一个 scope  参数来收集所有的 effect\n    // 而 effect 这个函数是对外的 api ，是不可以轻易改变参数的，所以会使用  new ReactiveEffect\n    // 因为 ReactiveEffect 是内部对象，加一个参数是无所谓的\n    // 后面如果要实现 scope 的逻辑的时候 需要改过来\n    // 现在就先算了\n    instance.update = effect(componentUpdateFn, {\n      scheduler: () => {\n        // 把 effect 推到微任务的时候在执行\n        // queueJob(effect);\n        queueJob(instance.update);\n      },\n    });\n  }\n  function updateComponentPreRender(instance, nextVNode) {\n    // 更新 nextVNode 的组件实例\n    // 现在 instance.vnode 是组件实例更新前的\n    // 所以之前的 props 就是基于 instance.vnode.props 来获取\n    // 接着需要更新 vnode ，方便下一次更新的时候获取到正确的值\n    nextVNode.component = instance;\n    // TODO 后面更新 props 的时候需要对比\n    // const prevProps = instance.vnode.props;\n    instance.vnode = nextVNode;\n    instance.next = null;\n\n    const { props } = nextVNode;\n    console.log('更新组件的 props', props);\n    instance.props = props;\n    console.log('更新组件的 slots');\n    // TODO 更新组件的 slots\n    // 需要重置 vnode\n  }\n\n  return {\n    render,\n    createApp: createAppAPI(render),\n  };\n}\n\n// 获取 数组最长递增子序列\nfunction getSequence(arr: number[]): number[] {\n  const p = arr.slice();\n  const result = [0];\n  let i, j, u, v, c;\n  const len = arr.length;\n  for (i = 0; i < len; i++) {\n    const arrI = arr[i];\n    if (arrI !== 0) {\n      j = result[result.length - 1];\n      if (arr[j] < arrI) {\n        p[i] = j;\n        result.push(i);\n        continue;\n      }\n      u = 0;\n      v = result.length - 1;\n      while (u < v) {\n        c = (u + v) >> 1;\n        if (arr[result[c]] < arrI) {\n          u = c + 1;\n        } else {\n          v = c;\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1];\n        }\n        result[u] = i;\n      }\n    }\n  }\n  u = result.length;\n  v = result[u - 1];\n  while (u-- > 0) {\n    result[u] = v;\n    v = p[v];\n  }\n  return result;\n}\n","// 源码里面这些接口是由 runtime-dom 来实现\n// 这里先简单实现\n\nimport { isOn } from \"@mini-vue/shared\";\nimport { createRenderer } from \"@mini-vue/runtime-core\";\n\n// 后面也修改成和源码一样的实现\nfunction createElement(type) {\n  console.log(\"CreateElement\", type);\n  const element = document.createElement(type);\n  return element;\n}\n\nfunction createText(text) {\n  return document.createTextNode(text);\n}\n\nfunction setText(node, text) {\n  node.nodeValue = text;\n}\n\nfunction setElementText(el, text) {\n  console.log(\"SetElementText\", el, text);\n  el.textContent = text;\n}\n\nfunction patchProp(el, key, preValue, nextValue) {\n  // preValue 之前的值\n  // 为了之后 update 做准备的值\n  // nextValue 当前的值\n  console.log(`PatchProp 设置属性:${key} 值:${nextValue}`);\n  console.log(`key: ${key} 之前的值是:${preValue}`);\n\n  if (isOn(key)) {\n    // 添加事件处理函数的时候需要注意一下\n    // 1. 添加的和删除的必须是一个函数，不然的话 删除不掉\n    //    那么就需要把之前 add 的函数给存起来，后面删除的时候需要用到\n    // 2. nextValue 有可能是匿名函数，当对比发现不一样的时候也可以通过缓存的机制来避免注册多次\n    // 存储所有的事件函数\n    const invokers = el._vei || (el._vei = {});\n    const existingInvoker = invokers[key];\n    if (nextValue && existingInvoker) {\n      // patch\n      // 直接修改函数的值即可\n      existingInvoker.value = nextValue;\n    } else {\n      const eventName = key.slice(2).toLowerCase();\n      if (nextValue) {\n        const invoker = (invokers[key] = nextValue);\n        el.addEventListener(eventName, invoker);\n      } else {\n        el.removeEventListener(eventName, existingInvoker);\n        invokers[key] = undefined;\n      }\n    }\n  } else {\n    if (nextValue === null || nextValue === \"\") {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, nextValue);\n    }\n  }\n}\n\nfunction insert(child, parent, anchor = null) {\n  console.log(\"Insert\");\n  parent.insertBefore(child, anchor);\n}\n\nfunction remove(child) {\n  const parent = child.parentNode;\n  if (parent) {\n    parent.removeChild(child);\n  }\n}\n\nlet renderer;\n\nfunction ensureRenderer() {\n  // 如果 renderer 有值的话，那么以后都不会初始化了\n  return (\n    renderer ||\n    (renderer = createRenderer({\n      createElement,\n      createText,\n      setText,\n      setElementText,\n      patchProp,\n      insert,\n      remove,\n    }))\n  );\n}\n\nexport const createApp = (...args) => {\n  return ensureRenderer().createApp(...args);\n};\n\nexport * from \"@mini-vue/runtime-core\"\n","export const TO_DISPLAY_STRING = Symbol(`toDisplayString`);\nexport const CREATE_ELEMENT_VNODE = Symbol(\"createElementVNode\");\n\nexport const helperNameMap = {\n  [TO_DISPLAY_STRING]: \"toDisplayString\",\n  [CREATE_ELEMENT_VNODE]: \"createElementVNode\"\n};\n","import { isString } from \"@mini-vue/shared\";\r\nimport { NodeTypes } from \"./ast\";\r\nimport {\r\n  CREATE_ELEMENT_VNODE,\r\n  helperNameMap,\r\n  TO_DISPLAY_STRING,\r\n} from \"./runtimeHelpers\";\r\n\r\nexport function generate(ast, options = {}) {\r\n  // 先生成 context\r\n  const context = createCodegenContext(ast, options);\r\n  const { push, mode } = context;\r\n\r\n  // 1. 先生成 preambleContext\r\n\r\n  if (mode === \"module\") {\r\n    genModulePreamble(ast, context);\r\n  } else {\r\n    genFunctionPreamble(ast, context);\r\n  }\r\n\r\n  const functionName = \"render\";\r\n\r\n  const args = [\"_ctx\"];\r\n\r\n  // _ctx,aaa,bbb,ccc\r\n  // 需要把 args 处理成 上面的 string\r\n  const signature = args.join(\", \");\r\n  push(`function ${functionName}(${signature}) {`);\r\n  // 这里需要生成具体的代码内容\r\n  // 开始生成 vnode tree 的表达式\r\n  push(\"return \");\r\n  genNode(ast.codegenNode, context);\r\n\r\n  push(\"}\");\r\n\r\n  return {\r\n    code: context.code,\r\n  };\r\n}\r\n\r\nfunction genFunctionPreamble(ast: any, context: any) {\r\n  const { runtimeGlobalName, push, newline } = context;\r\n  const VueBinging = runtimeGlobalName;\r\n\r\n  const aliasHelper = (s) => `${helperNameMap[s]} : _${helperNameMap[s]}`;\r\n\r\n  if (ast.helpers.length > 0) {\r\n    push(\r\n      `\r\n        const { ${ast.helpers.map(aliasHelper).join(\", \")}} = ${VueBinging} \r\n\r\n      `\r\n    );\r\n  }\r\n\r\n  newline();\r\n  push(`return `);\r\n}\r\n\r\nfunction genNode(node: any, context: any) {\r\n  // 生成代码的规则就是读取 node ，然后基于不同的 node 来生成对应的代码块\r\n  // 然后就是把代码快给拼接到一起就可以了\r\n\r\n  switch (node.type) {\r\n    case NodeTypes.INTERPOLATION:\r\n      genInterpolation(node, context);\r\n      break;\r\n    case NodeTypes.SIMPLE_EXPRESSION:\r\n      genExpression(node, context);\r\n      break;\r\n\r\n    case NodeTypes.ELEMENT:\r\n      genElement(node, context);\r\n      break;\r\n\r\n    case NodeTypes.COMPOUND_EXPRESSION:\r\n      genCompoundExpression(node, context);\r\n      break;\r\n\r\n    case NodeTypes.TEXT:\r\n      genText(node, context);\r\n      break;\r\n\r\n    default:\r\n      break;\r\n  }\r\n}\r\n\r\nfunction genCompoundExpression(node: any, context: any) {\r\n  const { push } = context;\r\n  for (let i = 0; i < node.children.length; i++) {\r\n    const child = node.children[i];\r\n    if (isString(child)) {\r\n      push(child);\r\n    } else {\r\n      genNode(child, context);\r\n    }\r\n  }\r\n}\r\n\r\nfunction genText(node: any, context: any) {\r\n  // Implement\r\n  const { push } = context;\r\n\r\n  push(`'${node.content}'`);\r\n}\r\n\r\nfunction genElement(node, context) {\r\n  const { push, helper } = context;\r\n  const { tag, props, children } = node;\r\n\r\n  push(`${helper(CREATE_ELEMENT_VNODE)}(`);\r\n\r\n  genNodeList(genNullableArgs([tag, props, children]), context);\r\n\r\n  push(`)`);\r\n}\r\n\r\nfunction genNodeList(nodes: any, context: any) {\r\n  const { push } = context;\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const node = nodes[i];\r\n\r\n    if (isString(node)) {\r\n      push(`${node}`);\r\n    } else {\r\n      genNode(node, context);\r\n    }\r\n    // node 和 node 之间需要加上 逗号(,)\r\n    // 但是最后一个不需要 \"div\", [props], [children]\r\n    if (i < nodes.length - 1) {\r\n      push(\", \");\r\n    }\r\n  }\r\n}\r\n\r\nfunction genNullableArgs(args) {\r\n  // 把末尾为null 的都删除掉\r\n  // vue3源码中，后面可能会包含 patchFlag、dynamicProps 等编译优化的信息\r\n  // 而这些信息有可能是不存在的，所以在这边的时候需要删除掉\r\n  let i = args.length;\r\n  // 这里 i-- 用的还是特别的巧妙的\r\n  // 当为0 的时候自然就退出循环了\r\n  while (i--) {\r\n    if (args[i] != null) break;\r\n  }\r\n\r\n  // 把为 falsy 的值都替换成 \"null\"\r\n  return args.slice(0, i + 1).map((arg) => arg || \"null\");\r\n}\r\n\r\nfunction genExpression(node: any, context: any) {\r\n  context.push(node.content, node);\r\n}\r\n\r\nfunction genInterpolation(node: any, context: any) {\r\n  const { push, helper } = context;\r\n  push(`${helper(TO_DISPLAY_STRING)}(`);\r\n  genNode(node.content, context);\r\n  push(\")\");\r\n}\r\n\r\nfunction genModulePreamble(ast, context) {\r\n  // preamble 就是 import 语句\r\n  const { push, newline, runtimeModuleName } = context;\r\n\r\n  if (ast.helpers.length) {\r\n    // 比如 ast.helpers 里面有个 [toDisplayString]\r\n    // 那么生成之后就是 import { toDisplayString as _toDisplayString } from \"vue\"\r\n    const code = `import {${ast.helpers\r\n      .map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`)\r\n      .join(\", \")} } from ${JSON.stringify(runtimeModuleName)}`;\r\n\r\n    push(code);\r\n  }\r\n\r\n  newline();\r\n  push(`export `);\r\n}\r\n\r\nfunction createCodegenContext(\r\n  ast: any,\r\n  { runtimeModuleName = \"vue\", runtimeGlobalName = \"Vue\", mode = \"function\" }\r\n): any {\r\n  const context = {\r\n    code: \"\",\r\n    mode,\r\n    runtimeModuleName,\r\n    runtimeGlobalName,\r\n    helper(key) {\r\n      return `_${helperNameMap[key]}`;\r\n    },\r\n    push(code) {\r\n      context.code += code;\r\n    },\r\n    newline() {\r\n      // 换新行\r\n      // TODO 需要额外处理缩进\r\n      context.code += \"\\n\";\r\n    },\r\n  };\r\n\r\n  return context;\r\n}\r\n","import { ElementTypes, NodeTypes } from \"./ast\";\n\nconst enum TagType {\n  Start,\n  End,\n}\n\nexport function baseParse(content: string) {\n  const context = createParserContext(content);\n  return createRoot(parseChildren(context, []));\n}\n\nfunction createParserContext(content) {\n  console.log(\"创建 paserContext\");\n  return {\n    source: content,\n  };\n}\n\nfunction parseChildren(context, ancestors) {\n  console.log(\"开始解析 children\");\n  const nodes: any = [];\n\n  while (!isEnd(context, ancestors)) {\n    let node;\n    const s = context.source;\n\n    if (startsWith(s, \"{{\")) {\n      // 看看如果是 {{ 开头的话，那么就是一个插值， 那么去解析他\n      node = parseInterpolation(context);\n    } else if (s[0] === \"<\") {\n      if (s[1] === \"/\") {\n        // 这里属于 edge case 可以不用关心\n        // 处理结束标签\n        if (/[a-z]/i.test(s[2])) {\n          // 匹配 </div>\n          // 需要改变 context.source 的值 -> 也就是需要移动光标\n          parseTag(context, TagType.End);\n          // 结束标签就以为这都已经处理完了，所以就可以跳出本次循环了\n          continue;\n        }\n      } else if (/[a-z]/i.test(s[1])) {\n        node = parseElement(context, ancestors);\n      }\n    }\n\n    if (!node) {\n      node = parseText(context);\n    }\n\n    nodes.push(node);\n  }\n\n  return nodes;\n}\n\nfunction isEnd(context: any, ancestors) {\n  // 检测标签的节点\n  // 如果是结束标签的话，需要看看之前有没有开始标签，如果有的话，那么也应该结束\n  // 这里的一个 edge case 是 <div><span></div>\n  // 像这种情况下，其实就应该报错\n  const s = context.source;\n  if (context.source.startsWith(\"</\")) {\n    // 从后面往前面查\n    // 因为便签如果存在的话 应该是 ancestors 最后一个元素\n    for (let i = ancestors.length - 1; i >= 0; --i) {\n      if (startsWithEndTagOpen(s, ancestors[i].tag)) {\n        return true;\n      }\n    }\n  }\n\n  // 看看 context.source 还有没有值\n  return !context.source;\n}\n\nfunction parseElement(context, ancestors) {\n  // 应该如何解析 tag 呢\n  // <div></div>\n  // 先解析开始 tag\n  const element = parseTag(context, TagType.Start);\n\n  ancestors.push(element);\n  const children = parseChildren(context, ancestors);\n  ancestors.pop();\n\n  // 解析 end tag 是为了检测语法是不是正确的\n  // 检测是不是和 start tag 一致\n  if (startsWithEndTagOpen(context.source, element.tag)) {\n    parseTag(context, TagType.End);\n  } else {\n    throw new Error(`缺失结束标签：${element.tag}`);\n  }\n\n  element.children = children;\n\n  return element;\n}\n\nfunction startsWithEndTagOpen(source: string, tag: string) {\n  // 1. 头部 是不是以  </ 开头的\n  // 2. 看看是不是和 tag 一样\n  return (\n    startsWith(source, \"</\") &&\n    source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase()\n  );\n}\n\nfunction parseTag(context: any, type: TagType): any {\n  // 发现如果不是 > 的话，那么就把字符都收集起来 ->div\n  // 正则\n  const match: any = /^<\\/?([a-z][^\\r\\n\\t\\f />]*)/i.exec(context.source);\n  const tag = match[1];\n\n  // 移动光标\n  // <div\n  advanceBy(context, match[0].length);\n\n  // 暂时不处理 selfClose 标签的情况 ，所以可以直接 advanceBy 1个坐标 <  的下一个就是 >\n  advanceBy(context, 1);\n\n  if (type === TagType.End) return;\n\n  let tagType = ElementTypes.ELEMENT;\n\n  return {\n    type: NodeTypes.ELEMENT,\n    tag,\n    tagType,\n  };\n}\n\nfunction parseInterpolation(context: any) {\n  // 1. 先获取到结束的index\n  // 2. 通过 closeIndex - startIndex 获取到内容的长度 contextLength\n  // 3. 通过 slice 截取内容\n\n  // }} 是插值的关闭\n  // 优化点是从 {{ 后面搜索即可\n  const openDelimiter = \"{{\";\n  const closeDelimiter = \"}}\";\n\n  const closeIndex = context.source.indexOf(\n    closeDelimiter,\n    openDelimiter.length\n  );\n\n  // TODO closeIndex -1 需要报错的\n\n  // 让代码前进2个长度，可以把 {{ 干掉\n  advanceBy(context, 2);\n\n  const rawContentLength = closeIndex - openDelimiter.length;\n  const rawContent = context.source.slice(0, rawContentLength);\n\n  const preTrimContent = parseTextData(context, rawContent.length);\n  const content = preTrimContent.trim();\n\n  // 最后在让代码前进2个长度，可以把 }} 干掉\n  advanceBy(context, closeDelimiter.length);\n\n  return {\n    type: NodeTypes.INTERPOLATION,\n    content: {\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      content,\n    },\n  };\n}\n\nfunction parseText(context): any {\n  console.log(\"解析 text\", context);\n\n  // endIndex 应该看看有没有对应的 <\n  // 比如 hello</div>\n  // 像这种情况下 endIndex 就应该是在 o 这里\n  // {\n  const endTokens = [\"<\", \"{{\"];\n  let endIndex = context.source.length;\n\n  for (let i = 0; i < endTokens.length; i++) {\n    const index = context.source.indexOf(endTokens[i]);\n    // endIndex > index 是需要要 endIndex 尽可能的小\n    // 比如说：\n    // hi, {{123}} <div></div>\n    // 那么这里就应该停到 {{ 这里，而不是停到 <div 这里\n    if (index !== -1 && endIndex > index) {\n      endIndex = index;\n    }\n  }\n\n  const content = parseTextData(context, endIndex);\n\n  return {\n    type: NodeTypes.TEXT,\n    content,\n  };\n}\n\nfunction parseTextData(context: any, length: number): any {\n  console.log(\"解析 textData\");\n  // 1. 直接返回 context.source\n  // 从 length 切的话，是为了可以获取到 text 的值（需要用一个范围来确定）\n  const rawText = context.source.slice(0, length);\n  // 2. 移动光标\n  advanceBy(context, length);\n\n  return rawText;\n}\n\nfunction advanceBy(context, numberOfCharacters) {\n  console.log(\"推进代码\", context, numberOfCharacters);\n  context.source = context.source.slice(numberOfCharacters);\n}\n\nfunction createRoot(children) {\n  return {\n    type: NodeTypes.ROOT,\n    children,\n    helpers: [],\n  };\n}\n\nfunction startsWith(source: string, searchString: string): boolean {\n  return source.startsWith(searchString);\n}\n","import { NodeTypes } from \"./ast\";\nimport { TO_DISPLAY_STRING } from \"./runtimeHelpers\";\n\nexport function transform(root, options = {}) {\n  // 1. 创建 context\n\n  const context = createTransformContext(root, options);\n\n  // 2. 遍历 node\n  traverseNode(root, context);\n\n  createRootCodegen(root, context);\n\n  root.helpers.push(...context.helpers.keys());\n}\n\nfunction traverseNode(node: any, context) {\n  const type: NodeTypes = node.type;\n\n  // 遍历调用所有的 nodeTransforms\n  // 把 node 给到 transform\n  // 用户可以对 node 做处理\n  const nodeTransforms = context.nodeTransforms;\n  const exitFns: any = [];\n  for (let i = 0; i < nodeTransforms.length; i++) {\n    const transform = nodeTransforms[i];\n\n    const onExit = transform(node, context);\n    if (onExit) {\n      exitFns.push(onExit);\n    }\n  }\n\n  switch (type) {\n    case NodeTypes.INTERPOLATION:\n      // 插值的点，在于后续生成 render 代码的时候是获取变量的值\n      context.helper(TO_DISPLAY_STRING);\n      break;\n\n    case NodeTypes.ROOT:\n    case NodeTypes.ELEMENT:\n\n      traverseChildren(node, context);\n      break;\n\n    default:\n      break;\n  }\n\n\n\n  let i = exitFns.length;\n  // i-- 这个很巧妙\n  // 使用 while 是要比 for 快 (可以使用 https://jsbench.me/ 来测试一下)\n  while (i--) {\n    exitFns[i]();\n  }\n}\n\nfunction traverseChildren(parent: any, context: any) {\n  // node.children\n  parent.children.forEach((node) => {\n    // TODO 需要设置 context 的值\n    traverseNode(node, context);\n  });\n}\n\nfunction createTransformContext(root, options): any {\n  const context = {\n    root,\n    nodeTransforms: options.nodeTransforms || [],\n    helpers: new Map(),\n    helper(name) {\n      // 这里会收集调用的次数\n      // 收集次数是为了给删除做处理的， （当只有 count 为0 的时候才需要真的删除掉）\n      // helpers 数据会在后续生成代码的时候用到\n      const count = context.helpers.get(name) || 0;\n      context.helpers.set(name, count + 1);\n    },\n  };\n\n  return context;\n}\n\nfunction createRootCodegen(root: any, context: any) {\n  const { children } = root;\n\n  // 只支持有一个根节点\n  // 并且还是一个 single text node\n  const child = children[0];\n\n  // 如果是 element 类型的话 ， 那么我们需要把它的 codegenNode 赋值给 root\n  // root 其实是个空的什么数据都没有的节点\n  // 所以这里需要额外的处理 codegenNode\n  // codegenNode 的目的是专门为了 codegen 准备的  为的就是和 ast 的 node 分离开\n  if (child.type === NodeTypes.ELEMENT && child.codegenNode) {\n    const codegenNode = child.codegenNode;\n    root.codegenNode = codegenNode;\n  } else {\n    root.codegenNode = child;\n  }\n}\n","import { NodeTypes } from \"../ast\";\r\n\r\nexport function transformExpression(node) {\r\n  if (node.type === NodeTypes.INTERPOLATION) {\r\n    node.content = processExpression(node.content);\r\n  }\r\n}\r\n\r\nfunction processExpression(node) {\r\n  node.content = `_ctx.${node.content}`;\r\n\r\n  return node\r\n}\r\n","import { CREATE_ELEMENT_VNODE } from \"./runtimeHelpers\";\n\nexport const enum NodeTypes {\n  TEXT,\n  ROOT,\n  INTERPOLATION,\n  SIMPLE_EXPRESSION,\n  ELEMENT,\n  COMPOUND_EXPRESSION\n}\n\nexport const enum ElementTypes {\n  ELEMENT,\n}\n\nexport function createSimpleExpression(content) {\n  return {\n    type: NodeTypes.SIMPLE_EXPRESSION,\n    content,\n  };\n}\n\nexport function createInterpolation(content) {\n  return {\n    type: NodeTypes.INTERPOLATION,\n    content: content,\n  };\n}\n\nexport function createVNodeCall(context, tag, props?, children?) {\n  if (context) {\n    context.helper(CREATE_ELEMENT_VNODE);\n  }\n\n  return {\n    // TODO vue3 里面这里的 type 是 VNODE_CALL\n    // 是为了 block 而 mini-vue 里面没有实现 block \n    // 所以创建的是 Element 类型就够用了\n    type: NodeTypes.ELEMENT,\n    tag,\n    props,\n    children,\n  };\n}\n","import { createVNodeCall, NodeTypes } from \"../ast\";\r\n\r\nexport function transformElement(node, context) {\r\n  if (node.type === NodeTypes.ELEMENT) {\r\n    return () => {\r\n      // 没有实现 block  所以这里直接创建 element\r\n\r\n      // TODO\r\n      // 需要把之前的 props 和 children 等一系列的数据都处理\r\n      const vnodeTag = `'${node.tag}'`;\r\n      // TODO props 暂时不支持\r\n      const vnodeProps = null;\r\n      let vnodeChildren = null;\r\n      if (node.children.length > 0) {\r\n        if (node.children.length === 1) {\r\n          // 只有一个孩子节点 ，那么当生成 render 函数的时候就不用 [] 包裹\r\n          const child = node.children[0];\r\n          vnodeChildren = child;\r\n        }\r\n      }\r\n\r\n      // 创建一个新的 node 用于 codegen 的时候使用\r\n      node.codegenNode = createVNodeCall(\r\n        context,\r\n        vnodeTag,\r\n        vnodeProps,\r\n        vnodeChildren\r\n      );\r\n    };\r\n  }\r\n}\r\n","import { NodeTypes } from \"./ast\";\r\n\r\nexport function isText(node) {\r\n  return node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT;\r\n}\r\n","import { NodeTypes } from \"../ast\";\r\nimport { isText } from \"../utils\";\r\n\r\nexport function transformText(node, context) {\r\n  if (node.type === NodeTypes.ELEMENT) {\r\n    // 在 exit 的时期执行\r\n    // 下面的逻辑会改变 ast 树\r\n    // 有些逻辑是需要在改变之前做处理的\r\n    return () => {\r\n      // hi,{{msg}}\r\n      // 上面的模块会生成2个节点，一个是 text 一个是 interpolation 的话\r\n      // 生成的 render 函数应该为 \"hi,\" + _toDisplayString(_ctx.msg)\r\n      // 这里面就会涉及到添加一个 “+” 操作符\r\n      // 那这里的逻辑就是处理它\r\n\r\n      // 检测下一个节点是不是 text 类型，如果是的话， 那么会创建一个 COMPOUND 类型\r\n      // COMPOUND 类型把 2个 text || interpolation 包裹（相当于是父级容器）\r\n\r\n      const children = node.children;\r\n      let currentContainer;\r\n\r\n      for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n\r\n        if (isText(child)) {\r\n          // 看看下一个节点是不是 text 类\r\n          for (let j = i + 1; j < children.length; j++) {\r\n            const next = children[j];\r\n            if (isText(next)) {\r\n              // currentContainer 的目的是把相邻的节点都放到一个 容器内\r\n              if (!currentContainer) {\r\n                currentContainer = children[i] = {\r\n                  type: NodeTypes.COMPOUND_EXPRESSION,\r\n                  loc: child.loc,\r\n                  children: [child],\r\n                };\r\n              }\r\n\r\n              currentContainer.children.push(` + `, next);\r\n              // 把当前的节点放到容器内, 然后删除掉j\r\n              children.splice(j, 1);\r\n              // 因为把 j 删除了，所以这里就少了一个元素，那么 j 需要 --\r\n              j--;\r\n            } else {\r\n              currentContainer = undefined;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n}\r\n","import { generate } from \"./codegen\";\r\nimport { baseParse } from \"./parse\";\r\nimport { transform } from \"./transform\";\r\nimport { transformExpression } from \"./transforms/transformExpression\";\r\nimport { transformElement } from \"./transforms/transformElement\";\r\nimport { transformText } from \"./transforms/transformText\";\r\n\r\nexport function baseCompile(template, options) {\r\n  // 1. 先把 template 也就是字符串 parse 成 ast\r\n  const ast = baseParse(template);\r\n  // 2. 给 ast 加点料（- -#）\r\n  transform(\r\n    ast,\r\n    Object.assign(options, {\r\n      nodeTransforms: [transformElement, transformText, transformExpression],\r\n    })\r\n  );\r\n\r\n  // 3. 生成 render 函数代码\r\n  return generate(ast);\r\n}\r\n","// mini-vue 出口\r\nexport * from '@mini-vue/runtime-dom';\r\nimport * as runtimeDom from \"@mini-vue/runtime-dom\";\r\nimport { baseCompile } from \"@mini-vue/compiler-core\";\r\nimport { registerRuntimeCompiler } from '@mini-vue/runtime-dom';\r\n\r\n\r\nfunction compileToFunction(template, options = {}) {\r\n  const { code } = baseCompile(template, options);\r\n\r\n  // 调用 compile 得到的代码在给封装到函数内，\r\n  // 这里会依赖 runtimeDom 的一些函数，所以在这里通过参数的形式注入进去\r\n  const render = new Function(\"Vue\", code)(runtimeDom);\r\n\r\n  return render;\r\n}\r\n\r\nregisterRuntimeCompiler(compileToFunction);\r\n"],"names":[],"mappings":"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"}